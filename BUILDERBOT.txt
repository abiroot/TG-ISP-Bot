# builderbot.vercel.app - Complete Documentation

Generated from 27 pages

## Documentation - BuilderBot.app Chatbot for Whatsapp, Telegram and more
URL: https://builderbot.vercel.app/quickstart#install
Section: Getting Started
Importance: 1.00
Description: This guide will get you all set up and ready to use the Protocol API. We’ll cover how to get started an API client and how to make your first API request.

Create Creating a bot is as simple as running the following command and following the instructions Prerequisites to consider before using this tool, Node v20 or higher and Git pnpmnpmpnpm create builderbot@latest CopyCopied! or you can use the following command to create a bot with the default configuration pnpmnpmpnpm create builderbot@latest --provider=baileys --database=memory --language=ts CopyCopied! Use the space key to select and the enter key to confirm. The CLI performs a preliminary check of the Node and operating system version, informing you if it meets the requirements or providing you with relevant information. In addition to generating a base project for you to simply start up If you have problems with your terminal try running the command with CMD, PowerShell, GitBash or another console you have installed. Requirements Make sure you have installed Node version 20 or higher, below you can see an example to check the version of node you are using. Node Versionnode -v v20.10.0 CopyCopied! Download node from its official website It is recommended to have GIT installed for proper operation. If you are using Linux or MacOc you probably already have GIT installed by default. Git Versiongit -v git version XXXX CopyCopied! Download GIT from its official website Base Example In this example we can see the basis of a simple bot which responds to the keywords sent by a user, the words are: info, hello, hi. You can see how to create the bot and implement the flows. main.tsmain.jsimport { createBot, createProvider, createFlow, addKeyword, MemoryDB } from '@builderbot/bot' import { BaileysProvider } from '@builderbot/provider-baileys' /** send static messages */ const welcomeFlow = addKeyword<BaileysProvider, MemoryDB>(['hello', 'hi']).addAnswer('Ey! welcome') /** send dynamic message from db or other sources */ const infoFlow = addKeyword<BaileysProvider, MemoryDB>('info') .addAction(async (ctx, { flowDynamic }) => { await flowDynamic(`Welcome ${ctx.name}`) }) /** send media files */ const mediaFlow = addKeyword<BaileysProvider, MemoryDB>('image') .addAnswer(`Send Image A`, { media: 'https://i.imgur.com/AsvWfUX.png' }) .addAction(async (ctx, { flowDynamic }) => { await flowDynamic(`Welcome ${ctx.name}`) await flowDynamic( [ { body: 'Send Image B', media: 'https://i.imgur.com/w0RtKnN.png' } ] ) }) /** initialization bot */ const main = async () => { const adapterDB = new MemoryDB() const adapterFlow = createFlow([welcomeFlow, infoFlow, mediaFlow]) const adapterProvider = createProvider(BaileysProvider) adapterProvider.initHttpServer(3000) await createBot({ flow: adapterFlow, provider: adapterProvider, database: adapterDB, }) } main() CopyCopied! ResourcesModularizeLearn how to modularise flows so that you can have a more maintainable bot.Send MessageHow to send a message via HTTP to start conversations, you can send multimedia as well.DockerizerA good practice is to dockerise your bots to make them more maintainable and effective.EventsLearning about events will make us more fluent when creating chatbots.

================================================================================

## How to implement a REST API? - BuilderBot.app Chatbot for Whatsapp, Telegram and more
URL: https://builderbot.vercel.app/tutorials/api-use
Section: API Reference
Importance: 1.00

How to implement a REST API? In many occasions we need to send a message via HTTP request is very useful to send reminders or order confirmations. In this case each provider implements a handleCtx function which allows you to inject the bot instantiation and access its functions from a controller. Send Single Message RequestPOST/v1/messagescurl https://api.example.chat/v1/messages \ -d number="34000000" \ -d message="Hello!" CopyCopied! In the exercise below you can get an example of how it works. It is interesting to understand that internally the library already implements a very light version of HTTP similar to express but called polka. app.tsimport 'dotenv/config' import { createBot, MemoryDB, createProvider } from '@builderbot/bot' import { BaileysProvider } from '@builderbot/provider-baileys' import flow from './flows'; const PORT = process.env.PORT ?? 3001 const main = async () => { const provider = createProvider(BaileysProvider) const { handleCtx, httpServer } = await createBot({ database: new MemoryDB(), provider, flow, }) httpServer(+PORT) provider.server.post('/v1/messages', handleCtx(async (bot, req, res) => { const { number, message } = req.body await bot.sendMessage(number, message, {}) return res.end('send') })) } main() CopyCopied! Send with Media RequestMedia LinkMedia LocalPOST/v1/messagescurl https://api.example.chat/v1/messages \ -d number="34000000" \ -d message="Ey! send media" CopyCopied! In the following example you will understand how to send files, images or videos from an api when the file is in a public URL or also if you want to upload it through a request. app-media.tsapp-media.storage.tsimport 'dotenv/config' import { createBot, MemoryDB, createProvider } from '@builderbot/bot' import { BaileysProvider } from '@builderbot/provider-baileys' import flow from './flows'; const PORT = process.env.PORT ?? 3001 const main = async () => { const provider = createProvider(BaileysProvider) const { handleCtx, httpServer } = await createBot({ database: new MemoryDB(), provider, flow, }) httpServer(+PORT) provider.server.post('/v1/messages', handleCtx(async (bot, req, res) => { const { number, message, media } = req.body await bot.sendMessage(number, message, { media }) // https://i.imgur.com/0HpzsEm.png return res.end('send') })) } main() CopyCopied! Block Users RequestPOST/v1/blacklistcurl https://api.example.chat/v1/blacklist \ -d number="34000000" \ -d intent="'add' or 'remove'" CopyCopied! In the following example you will understand how to add numbers to a blacklist to prevent the bot from answering those numbers, very useful when we want to talk to a person without the bot answering. blacklist-api.tsimport { createBot, MemoryDB, createProvider } from '@builderbot/bot' import { BaileysProvider } from '@builderbot/provider-baileys' import flow from './flows'; const PORT = process.env.PORT ?? 3001 const main = async () => { const provider = createProvider(BaileysProvider) const { handleCtx, httpServer } = await createBot({ database: new MemoryDB(), provider, flow, }) httpServer(+PORT) provider.server.post('/v1/blacklist', handleCtx(async (bot, req, res) => { const { number, intent } = req.body if (intent === 'remove') bot.blacklist.remove(`340000000`) if (intent === 'add') bot.blacklist.add(`340000000`) res.writeHead(200, { 'Content-Type': 'application/json' }) return res.end(JSON.stringify({ status: 'ok', number, intent })) })) } main() CopyCopied! Trigger Flows RequestPOST/v1/registercurl https://api.example.chat/v1/register \ -d number="34000000" \ -d name ="Joe" CopyCopied! In the following example you will understand how to start a flow to a given number from an API request, it is a new experimental function that may undergo changes in the future. trigger-flow-api.tsimport { createBot, MemoryDB, createProvider } from '@builderbot/bot' import { BaileysProvider } from '@builderbot/provider-baileys' const PORT = process.env.PORT ?? 3001 const registerFlow = addKeyword(utils.setEvent('EVENT_REGISTER')) .addAnswer(`What is your name?`, { capture: true }, async (ctx, { state }) => { await state.update({ name: ctx.body }) }) .addAnswer('What is your age?', { capture: true }, async (ctx, { state }) => { await state.update({ age: ctx.body }) }) .addAction(async (_, { flowDynamic, state }) => { await flowDynamic(`${state.get('name')}, thanks for your information!: Your age: ${state.get('age')}`) }) const main = async () => { const provider = createProvider(BaileysProvider) const { handleCtx, httpServer } = await createBot({ database: new MemoryDB(), provider, flow: createFlow([registerFlow]), }) httpServer(+PORT) provider.server.post('/v1/register', handleCtx(async (bot, req, res) => { const { number, name } = req.body await bot.dispatch('EVENT_REGISTER', { from: number, name }) return res.end('trigger') })) } main() CopyCopied! GuidesMy first chatbotLearn how build your first chatbot in few minutesRead moreConceptsUnderstand the essential concepts for building botsRead moreAdd FunctionsThe key to learning how to write flows is add-functions.Read morePluginsUnlimitate and start implementing the community plugins.Read more ResourcesModularizeLearn how to modularise flows so that you can have a more maintainable bot.Send MessageHow to send a message via HTTP to start conversations, you can send multimedia as well.DockerizerA good practice is to dockerise your bots to make them more maintainable and effective.EventsLearning about events will make us more fluent when creating chatbots.

================================================================================

## Documentation - BuilderBot.app Chatbot for Whatsapp, Telegram and more
URL: https://builderbot.vercel.app/en/quickstart#create
Section: Getting Started
Importance: 1.00
Description: This guide will get you all set up and ready to use the Protocol API. We’ll cover how to get started an API client and how to make your first API request.

Create Creating a bot is as simple as running the following command and following the instructions Prerequisites to consider before using this tool, Node v20 or higher and Git pnpmnpmpnpm create builderbot@latest CopyCopied! or you can use the following command to create a bot with the default configuration pnpmnpmpnpm create builderbot@latest --provider=baileys --database=memory --language=ts CopyCopied! Use the space key to select and the enter key to confirm. The CLI performs a preliminary check of the Node and operating system version, informing you if it meets the requirements or providing you with relevant information. In addition to generating a base project for you to simply start up If you have problems with your terminal try running the command with CMD, PowerShell, GitBash or another console you have installed. Requirements Make sure you have installed Node version 20 or higher, below you can see an example to check the version of node you are using. Node Versionnode -v v20.10.0 CopyCopied! Download node from its official website It is recommended to have GIT installed for proper operation. If you are using Linux or MacOc you probably already have GIT installed by default. Git Versiongit -v git version XXXX CopyCopied! Download GIT from its official website Base Example In this example we can see the basis of a simple bot which responds to the keywords sent by a user, the words are: info, hello, hi. You can see how to create the bot and implement the flows. main.tsmain.jsimport { createBot, createProvider, createFlow, addKeyword, MemoryDB } from '@builderbot/bot' import { BaileysProvider } from '@builderbot/provider-baileys' /** send static messages */ const welcomeFlow = addKeyword<BaileysProvider, MemoryDB>(['hello', 'hi']).addAnswer('Ey! welcome') /** send dynamic message from db or other sources */ const infoFlow = addKeyword<BaileysProvider, MemoryDB>('info') .addAction(async (ctx, { flowDynamic }) => { await flowDynamic(`Welcome ${ctx.name}`) }) /** send media files */ const mediaFlow = addKeyword<BaileysProvider, MemoryDB>('image') .addAnswer(`Send Image A`, { media: 'https://i.imgur.com/AsvWfUX.png' }) .addAction(async (ctx, { flowDynamic }) => { await flowDynamic(`Welcome ${ctx.name}`) await flowDynamic( [ { body: 'Send Image B', media: 'https://i.imgur.com/w0RtKnN.png' } ] ) }) /** initialization bot */ const main = async () => { const adapterDB = new MemoryDB() const adapterFlow = createFlow([welcomeFlow, infoFlow, mediaFlow]) const adapterProvider = createProvider(BaileysProvider) adapterProvider.initHttpServer(3000) await createBot({ flow: adapterFlow, provider: adapterProvider, database: adapterDB, }) } main() CopyCopied! ResourcesModularizeLearn how to modularise flows so that you can have a more maintainable bot.Send MessageHow to send a message via HTTP to start conversations, you can send multimedia as well.DockerizerA good practice is to dockerise your bots to make them more maintainable and effective.EventsLearning about events will make us more fluent when creating chatbots.

================================================================================

## How to implement a REST API? - BuilderBot.app Chatbot for Whatsapp, Telegram and more
URL: https://builderbot.vercel.app/en/tutorials/api-use#guides
Section: API Reference
Importance: 1.00

How to implement a REST API? In many occasions we need to send a message via HTTP request is very useful to send reminders or order confirmations. In this case each provider implements a handleCtx function which allows you to inject the bot instantiation and access its functions from a controller. Send Single Message RequestPOST/v1/messagescurl https://api.example.chat/v1/messages \ -d number="34000000" \ -d message="Hello!" CopyCopied! In the exercise below you can get an example of how it works. It is interesting to understand that internally the library already implements a very light version of HTTP similar to express but called polka. app.tsimport 'dotenv/config' import { createBot, MemoryDB, createProvider } from '@builderbot/bot' import { BaileysProvider } from '@builderbot/provider-baileys' import flow from './flows'; const PORT = process.env.PORT ?? 3001 const main = async () => { const provider = createProvider(BaileysProvider) const { handleCtx, httpServer } = await createBot({ database: new MemoryDB(), provider, flow, }) httpServer(+PORT) provider.server.post('/v1/messages', handleCtx(async (bot, req, res) => { const { number, message } = req.body await bot.sendMessage(number, message, {}) return res.end('send') })) } main() CopyCopied! Send with Media RequestMedia LinkMedia LocalPOST/v1/messagescurl https://api.example.chat/v1/messages \ -d number="34000000" \ -d message="Ey! send media" CopyCopied! In the following example you will understand how to send files, images or videos from an api when the file is in a public URL or also if you want to upload it through a request. app-media.tsapp-media.storage.tsimport 'dotenv/config' import { createBot, MemoryDB, createProvider } from '@builderbot/bot' import { BaileysProvider } from '@builderbot/provider-baileys' import flow from './flows'; const PORT = process.env.PORT ?? 3001 const main = async () => { const provider = createProvider(BaileysProvider) const { handleCtx, httpServer } = await createBot({ database: new MemoryDB(), provider, flow, }) httpServer(+PORT) provider.server.post('/v1/messages', handleCtx(async (bot, req, res) => { const { number, message, media } = req.body await bot.sendMessage(number, message, { media }) // https://i.imgur.com/0HpzsEm.png return res.end('send') })) } main() CopyCopied! Block Users RequestPOST/v1/blacklistcurl https://api.example.chat/v1/blacklist \ -d number="34000000" \ -d intent="'add' or 'remove'" CopyCopied! In the following example you will understand how to add numbers to a blacklist to prevent the bot from answering those numbers, very useful when we want to talk to a person without the bot answering. blacklist-api.tsimport { createBot, MemoryDB, createProvider } from '@builderbot/bot' import { BaileysProvider } from '@builderbot/provider-baileys' import flow from './flows'; const PORT = process.env.PORT ?? 3001 const main = async () => { const provider = createProvider(BaileysProvider) const { handleCtx, httpServer } = await createBot({ database: new MemoryDB(), provider, flow, }) httpServer(+PORT) provider.server.post('/v1/blacklist', handleCtx(async (bot, req, res) => { const { number, intent } = req.body if (intent === 'remove') bot.blacklist.remove(`340000000`) if (intent === 'add') bot.blacklist.add(`340000000`) res.writeHead(200, { 'Content-Type': 'application/json' }) return res.end(JSON.stringify({ status: 'ok', number, intent })) })) } main() CopyCopied! Trigger Flows RequestPOST/v1/registercurl https://api.example.chat/v1/register \ -d number="34000000" \ -d name ="Joe" CopyCopied! In the following example you will understand how to start a flow to a given number from an API request, it is a new experimental function that may undergo changes in the future. trigger-flow-api.tsimport { createBot, MemoryDB, createProvider } from '@builderbot/bot' import { BaileysProvider } from '@builderbot/provider-baileys' const PORT = process.env.PORT ?? 3001 const registerFlow = addKeyword(utils.setEvent('EVENT_REGISTER')) .addAnswer(`What is your name?`, { capture: true }, async (ctx, { state }) => { await state.update({ name: ctx.body }) }) .addAnswer('What is your age?', { capture: true }, async (ctx, { state }) => { await state.update({ age: ctx.body }) }) .addAction(async (_, { flowDynamic, state }) => { await flowDynamic(`${state.get('name')}, thanks for your information!: Your age: ${state.get('age')}`) }) const main = async () => { const provider = createProvider(BaileysProvider) const { handleCtx, httpServer } = await createBot({ database: new MemoryDB(), provider, flow: createFlow([registerFlow]), }) httpServer(+PORT) provider.server.post('/v1/register', handleCtx(async (bot, req, res) => { const { number, name } = req.body await bot.dispatch('EVENT_REGISTER', { from: number, name }) return res.end('trigger') })) } main() CopyCopied! GuidesMy first chatbotLearn how build your first chatbot in few minutesRead moreConceptsUnderstand the essential concepts for building botsRead moreAdd FunctionsThe key to learning how to write flows is add-functions.Read morePluginsUnlimitate and start implementing the community plugins.Read more ResourcesModularizeLearn how to modularise flows so that you can have a more maintainable bot.Send MessageHow to send a message via HTTP to start conversations, you can send multimedia as well.DockerizerA good practice is to dockerise your bots to make them more maintainable and effective.EventsLearning about events will make us more fluent when creating chatbots.

================================================================================

## Documentation - BuilderBot.app Chatbot for Whatsapp, Telegram and more
URL: https://builderbot.vercel.app/add-functions
Section: Documentation
Importance: 0.80
Description: In this guide, we will talk about what happens when something goes wrong while you work with the API.

Add keyword addKeyword is the starting point of a conversation flow, just need to pass an array of keywords, when someone text those keywords in the chatbot, the function will trigger the predefined dialog you have set up. In the following example is stablished a conversation flow that received the keywords 'hello' and 'hi', then the chatbot will send a message using addAnswer with the text 'Hi, welcome to my amazing shop, how can I help you?' and 'The shop offers: shoes, shirts, pants, and hats'. The addKeywords function also has a number of proprieties that will help you solve different use cases. Some of these functions are: regex, sensitive app.tsapp.js import { addKeyword } from '@builderbot/bot'; const mainFlow = addKeyword(['hello', 'hi']) .addAnswer(['Hi, welcome to my amazing shop', 'how can I help you?']) .addAnswer(['The shop has: ', 'shoes, shirts, pants, and hats']) CopyCopied! The conversation flow can be limited to a specific keyword, in example the word 'purchase' to trigger the next dialog app.tsapp.js import { addKeyword } from '@builderbot/bot'; const mainFlow = addKeyword('buy') .addAnswer(['Great! ', 'What do you want to buy?']) CopyCopied! addKeywordRegex The chatbot supports regex validation, in the following example an object is passed as the second parameter to the addKeyword function, the object has a property regex set to true and the keywords property is a regex pattern.app.tsapp.js import { addKeyword } from '@builderbot/bot'; const REGEX_GMAIL_EMAIL = /(\w+)@gmail\.com/g; const mainFlow = addKeyword(REGEX_GMAIL_EMAIL, { regex: true }) .addAnswer(`Thanks for the gmail address`) CopyCopied! addKeywordSensitive The chatbot detects an specific keyword in any part of a message, but passing the sensitive property as true the chatbot will trigger the dialog if the user write down the exact same keyword.app.tsapp.js import { addKeyword } from '@builderbot/bot'; const mainFlow = addKeyword('buy', { sensitive: true }) .addAnswer(['Great! ', 'What do you want to buy?']) CopyCopied! Add answer addAnswer is used to send a message to the user, it can be a simple text or a file attached. In the following example is stablished a conversation flow that received the keyword 'hello', then the chatbot will send a message using addAnswer with the text 'Hi, welcome to my amazing shop, how can I help you?' app.tsapp.js import { addKeyword, addAnswer } from '@builderbot/bot'; const mainFlow = addKeyword('hello') .addAnswer('Hi, welcome to my amazing shop, how can I help you?') CopyCopied! There are different settings for sending messages, some functions such as sending files, images, video, delays, line breaks: line breaks, consecutive, delay , callback addAnswerConsecutive Messages The chatbot can send multiple messages just adding the addAnswer function one after another. In the following example the chatbot will send (3) messages: Hi, Welcome to my amazing shop, how can I help you? in that order.app.tsapp.js import { addKeyword, addAnswer } from '@builderbot/bot'; const mainFlow = addKeyword('hello') .addAnswer('Hi') .addAnswer('Welcome to my amazing shop') .addAnswer('how can I help you?') CopyCopied! addAnswerMessage with line breaks Whenever you need to send a message with line breaks, you can use an array of string as you can see in the following example.app.tsapp.js import { addKeyword, addAnswer } from '@builderbot/bot'; const mainFlow = addKeyword('hello') .addAnswer([ 'Hi', 'Welcome to my amazing shop', 'how can I help you?' ]) CopyCopied! addAnswerMessage with delay The chatbot can send a message with a delay, just add the addAnswer function with the delay property set to the amount of milliseconds you want to wait before sending the message.app.tsapp.jsimport { addKeyword, addAnswer } from '@builderbot/bot'; const mainFlow = addKeyword('hello') .addAnswer('This message will after 2 seconds', { delay: 2000 } ) CopyCopied! Message with callback When using callback functions in an addAnswers the operation prioritizes the sending of the message and then the execution of the function. app.tsapp.js import { addKeyword, addAnswer } from '@builderbot/bot'; const mainFlow = addKeyword('hello') .addAnswer('Hi!, Do you know 4+4?', null, async (_, {flowDynamic}) => { const sum = 4 + 4 await flowDynamic(`Total: ${sum}`) }) .addAction(async (_, {flowDynamic}) => { await flowDynamic(`Other message`) }) CopyCopied! Add Action addAction is used to define specific actions as a response when a whatsapp message has been received, this function allows to trigger conversation flows based on the user's input and define how the chatbot should act. In the folowing example you can see how you can trigger a function when the user sends a message with the keyword 'buy'. app.tsapp.js import { addKeyword, addAction } from '@builderbot/bot'; const mainFlow = addKeyword('buy') .addAnswer('Great! What do you want to buy?') .addAction(async (_, { flowDynamic }): void => { return console.log('The user wants to buy something'); }) CopyCopied! You can use the addAction function with capture as you can see in the example below app.tsapp.js import { addKeyword, addAction } from '@builderbot/bot'; const mainFlow = addKeyword(['Hello', 'Hi']) .addAction(async (_, { flowDynamic }): void => { return flowDynamic('Hi! how can I help you?'); }) .addAction({ capture: true }, async (ctx, { flowDynamic, state }): void => { await state.udpate({ name: ctx.body}) return console.flowDynamic(`The user said: ${ctx.body}`); }) CopyCopied! GuidesMy first chatbotLearn how build your first chatbot in few minutesRead moreConceptsUnderstand the essential concepts for building botsRead moreAdd FunctionsThe key to learning how to write flows is add-functions.Read morePluginsUnlimitate and start implementing the community plugins.Read more ResourcesModularizeLearn how to modularise flows so that you can have a more maintainable bot.Send MessageHow to send a message via HTTP to start conversations, you can send multimedia as well.DockerizerA good practice is to dockerise your bots to make them more maintainable and effective.EventsLearning about events will make us more fluent when creating chatbots.

================================================================================

## Documentation - BuilderBot.app Chatbot for Whatsapp, Telegram and more
URL: https://builderbot.vercel.app/en/add-functions#regex
Section: Documentation
Importance: 0.70
Description: In this guide, we will talk about what happens when something goes wrong while you work with the API.

Add keyword addKeyword is the starting point of a conversation flow, just need to pass an array of keywords, when someone text those keywords in the chatbot, the function will trigger the predefined dialog you have set up. In the following example is stablished a conversation flow that received the keywords 'hello' and 'hi', then the chatbot will send a message using addAnswer with the text 'Hi, welcome to my amazing shop, how can I help you?' and 'The shop offers: shoes, shirts, pants, and hats'. The addKeywords function also has a number of proprieties that will help you solve different use cases. Some of these functions are: regex, sensitive app.tsapp.js import { addKeyword } from '@builderbot/bot'; const mainFlow = addKeyword(['hello', 'hi']) .addAnswer(['Hi, welcome to my amazing shop', 'how can I help you?']) .addAnswer(['The shop has: ', 'shoes, shirts, pants, and hats']) CopyCopied! The conversation flow can be limited to a specific keyword, in example the word 'purchase' to trigger the next dialog app.tsapp.js import { addKeyword } from '@builderbot/bot'; const mainFlow = addKeyword('buy') .addAnswer(['Great! ', 'What do you want to buy?']) CopyCopied! addKeywordRegex The chatbot supports regex validation, in the following example an object is passed as the second parameter to the addKeyword function, the object has a property regex set to true and the keywords property is a regex pattern.app.tsapp.js import { addKeyword } from '@builderbot/bot'; const REGEX_GMAIL_EMAIL = /(\w+)@gmail\.com/g; const mainFlow = addKeyword(REGEX_GMAIL_EMAIL, { regex: true }) .addAnswer(`Thanks for the gmail address`) CopyCopied! addKeywordSensitive The chatbot detects an specific keyword in any part of a message, but passing the sensitive property as true the chatbot will trigger the dialog if the user write down the exact same keyword.app.tsapp.js import { addKeyword } from '@builderbot/bot'; const mainFlow = addKeyword('buy', { sensitive: true }) .addAnswer(['Great! ', 'What do you want to buy?']) CopyCopied! Add answer addAnswer is used to send a message to the user, it can be a simple text or a file attached. In the following example is stablished a conversation flow that received the keyword 'hello', then the chatbot will send a message using addAnswer with the text 'Hi, welcome to my amazing shop, how can I help you?' app.tsapp.js import { addKeyword, addAnswer } from '@builderbot/bot'; const mainFlow = addKeyword('hello') .addAnswer('Hi, welcome to my amazing shop, how can I help you?') CopyCopied! There are different settings for sending messages, some functions such as sending files, images, video, delays, line breaks: line breaks, consecutive, delay , callback addAnswerConsecutive Messages The chatbot can send multiple messages just adding the addAnswer function one after another. In the following example the chatbot will send (3) messages: Hi, Welcome to my amazing shop, how can I help you? in that order.app.tsapp.js import { addKeyword, addAnswer } from '@builderbot/bot'; const mainFlow = addKeyword('hello') .addAnswer('Hi') .addAnswer('Welcome to my amazing shop') .addAnswer('how can I help you?') CopyCopied! addAnswerMessage with line breaks Whenever you need to send a message with line breaks, you can use an array of string as you can see in the following example.app.tsapp.js import { addKeyword, addAnswer } from '@builderbot/bot'; const mainFlow = addKeyword('hello') .addAnswer([ 'Hi', 'Welcome to my amazing shop', 'how can I help you?' ]) CopyCopied! addAnswerMessage with delay The chatbot can send a message with a delay, just add the addAnswer function with the delay property set to the amount of milliseconds you want to wait before sending the message.app.tsapp.jsimport { addKeyword, addAnswer } from '@builderbot/bot'; const mainFlow = addKeyword('hello') .addAnswer('This message will after 2 seconds', { delay: 2000 } ) CopyCopied! Message with callback When using callback functions in an addAnswers the operation prioritizes the sending of the message and then the execution of the function. app.tsapp.js import { addKeyword, addAnswer } from '@builderbot/bot'; const mainFlow = addKeyword('hello') .addAnswer('Hi!, Do you know 4+4?', null, async (_, {flowDynamic}) => { const sum = 4 + 4 await flowDynamic(`Total: ${sum}`) }) .addAction(async (_, {flowDynamic}) => { await flowDynamic(`Other message`) }) CopyCopied! Add Action addAction is used to define specific actions as a response when a whatsapp message has been received, this function allows to trigger conversation flows based on the user's input and define how the chatbot should act. In the folowing example you can see how you can trigger a function when the user sends a message with the keyword 'buy'. app.tsapp.js import { addKeyword, addAction } from '@builderbot/bot'; const mainFlow = addKeyword('buy') .addAnswer('Great! What do you want to buy?') .addAction(async (_, { flowDynamic }): void => { return console.log('The user wants to buy something'); }) CopyCopied! You can use the addAction function with capture as you can see in the example below app.tsapp.js import { addKeyword, addAction } from '@builderbot/bot'; const mainFlow = addKeyword(['Hello', 'Hi']) .addAction(async (_, { flowDynamic }): void => { return flowDynamic('Hi! how can I help you?'); }) .addAction({ capture: true }, async (ctx, { flowDynamic, state }): void => { await state.udpate({ name: ctx.body}) return console.flowDynamic(`The user said: ${ctx.body}`); }) CopyCopied! GuidesMy first chatbotLearn how build your first chatbot in few minutesRead moreConceptsUnderstand the essential concepts for building botsRead moreAdd FunctionsThe key to learning how to write flows is add-functions.Read morePluginsUnlimitate and start implementing the community plugins.Read more ResourcesModularizeLearn how to modularise flows so that you can have a more maintainable bot.Send MessageHow to send a message via HTTP to start conversations, you can send multimedia as well.DockerizerA good practice is to dockerise your bots to make them more maintainable and effective.EventsLearning about events will make us more fluent when creating chatbots.

================================================================================

## Events - BuilderBot.app Chatbot for Whatsapp, Telegram and more
URL: https://builderbot.vercel.app/en/events#guides
Section: Getting Started
Importance: 0.70
Description: In this guide, we will talk about what happens when something goes wrong while you work with the API.

Events Sometimes users send messages such as an image, a video or special location messages, among others, to receive and start a conversation when a message of this type arrives we can use the events. WELCOMEDefault When a user sends a "text" message that does not exist in a keyword on another flow, the WELCOME event will be triggered by default, which is the default event. Let's imagine the case in which a person writes the word Thank you! app.tsapp.js import { addKeyword, EVENTS } from '@builderbot/bot' const welcomeFlow = addKeyword(EVENTS.WELCOME).addAnswer('Ey welcome?') const greetingFlow = addKeyword(['hello','hi']).addAnswer('Hi!') CopyCopied! We can see in the diagram above that the bot does a search in all the flows to get the best flow that can respond to the keyword "Thank You" but as it does not find then the "WELCOME" is triggered. MEDIAReceived Image or Video When a user sends an image or a video, the MEDIA event, which is the default event, will be triggered by default. This is ideal for when we need them to send information and we need to store it. app.tsapp.js import { addKeyword, EVENTS } from '@builderbot/bot' const mediaFlow = addKeyword(EVENTS.MEDIA).addAnswer('I received a media image/video') CopyCopied! To save the media file you must invoke the saveFile function from the provider you are using. app.tsapp.js import { addKeyword, EVENTS } from '@builderbot/bot' import { BaileysProvider } from '@builderbot/provider-baileys' const mediaFlow = addKeyword<BaileysProvider>(EVENTS.MEDIA) .addAnswer('I received a media image/video', async (ctx, { provider }) => { const localPath = await provider.saveFile(ctx, {path:'...'}) //console.log(localPath) }) CopyCopied! DOCUMENTReceived Document When a user sends a document, DOCUMENT event will be triggered by default, which is the default event. app.tsapp.js import { addKeyword, EVENTS } from '@builderbot/bot' const documentFlow = addKeyword(EVENTS.DOCUMENT) .addAnswer("Wow! I'm sorry I can't read this document right now", async (ctx, { provider }) => { const localPath = await provider.saveFile(ctx, {path:'...'}) //console.log(localPath) }) CopyCopied! LOCATIONReceived Location Location must be sent via WhatsApp, does not yet allow location links from external apps When your chatbot needs to access a user's location, it's important to ensure that the location is sent directly from the WhatsApp app to have results. Once the location is received, you can perform a console log of ctx to view the details of the received location. The received location context will look something like this in console: ctx: { ... message: Message { locationMessage: LocationMessage { degreesLatitude: -2.1462137699127197, degreesLongitude: -79.88981628417969, name: 'Doctor Miguel Angel Jijón Teran', address: 'Doctor Miguel Angel Jijón Teran, Guayaquil, Ecuador', }, }, body: '_event_location__0d5c9f57-0909-44a1-995f-902f9df3b21f', name: 'yeyodev 👨🏾‍💻', from: '593000000000' } CopyCopied! This will output the user's latitude and longitude in the console, allowing you to effectively utilize the location data for your chatbot's functionality. To access the location data, you can use the following approach: location.flow.tslocation.flow.jsimport { EVENTS, addKeyword } from "@builderbot/bot"; export default addKeyword(EVENTS.LOCATION) .addAnswer("I have received your location!", null, async (ctx) => { const userLatitude = ctx.message.locationMessage.degreesLatitude; const userLongitude = ctx.message.locationMessage.degreesLongitude; }) CopyCopied! VOICE_NOTEReceived Voice Note When a user sends a voice note, the VOICE_NOTE event will be triggered by default, which is the event intended for this behavior, it is important to understand that a voice note is different from an image or video file. app.tsapp.js import { addKeyword, EVENTS } from '@builderbot/bot' const voiceNoteFlow = addKeyword(EVENTS.VOICE_NOTE) .addAnswer('Give me a second to hear you!', async (ctx, { provider }) => { const localPath = await provider.saveFile(ctx, {path:'...'}) //console.log(localPath) }) CopyCopied! GuidesMy first chatbotLearn how build your first chatbot in few minutesRead moreConceptsUnderstand the essential concepts for building botsRead moreAdd FunctionsThe key to learning how to write flows is add-functions.Read morePluginsUnlimitate and start implementing the community plugins.Read more ResourcesModularizeLearn how to modularise flows so that you can have a more maintainable bot.Send MessageHow to send a message via HTTP to start conversations, you can send multimedia as well.DockerizerA good practice is to dockerise your bots to make them more maintainable and effective.EventsLearning about events will make us more fluent when creating chatbots.

================================================================================

## BuilderBot.app Create a WhatsApp Chatbot, Without Limit
URL: https://builderbot.vercel.app/en
Section: General
Importance: 0.60
Description: BuilderBot With this library, you can set up automated responses to frequently asked questions, receive and respond to messages in an automated way, and track customer interactions. In addition, our Chatbot integrates easily with other systems and tools you are already using in your business.

Get started with BuilderBot This is a free and open source framework with an intuitive and extensible way to create chatbot and smart apps that connect to different communication channels like Whatsapp, Telegram and others. We have made an intuitive framework so you can have your first chatbot in minutes. Winner of the first prize at OpenExpo 2024 🏆 Quick Start To create quickly with the following command pnpmnpmpnpm create builderbot@latest CopyCopied! Installation and requirements ⚡ Building an AI bot In this few minutes tutorial you can have your own chatbot with whatsapp and artificial intelligence to talk about your business. Learn how to create a bot with the new open ai assistants Code repository Quick Example In this example we can see the basis of a simple bot which responds to the keywords sent by a user, the words are: info, hello, hi. You can see how to create the bot and implement the flows. main.tsmain.jsimport { createBot, createProvider, createFlow, addKeyword, MemoryDB } from '@builderbot/bot' import { BaileysProvider } from '@builderbot/provider-baileys' const welcomeFlow = addKeyword<BaileysProvider, MemoryDB>(['hello', 'hi']) .addAnswer('Ey! welcome') .addAnswer(`Send image from URL`, { media: 'https://i.imgur.com/0HpzsEm.png' }) const main = async () => { const adapterDB = new MemoryDB() const adapterFlow = createFlow([welcomeFlow]) const adapterProvider = createProvider(BaileysProvider) const { handleCtx, httpServer } = await createBot({ flow: adapterFlow, provider: adapterProvider, database: adapterDB, }) httpServer(3000) adapterProvider.server.post('/v1/messages', handleCtx(async (bot, req, res) => { const { number, message } = req.body await bot.sendMessage(number, message, {}) return res.end('send') })) } main() CopyCopied! GuidesMy first chatbotLearn how build your first chatbot in few minutesRead moreConceptsUnderstand the essential concepts for building botsRead moreAdd FunctionsThe key to learning how to write flows is add-functions.Read morePluginsUnlimitate and start implementing the community plugins.Read more ResourcesModularizeLearn how to modularise flows so that you can have a more maintainable bot.Send MessageHow to send a message via HTTP to start conversations, you can send multimedia as well.DockerizerA good practice is to dockerise your bots to make them more maintainable and effective.EventsLearning about events will make us more fluent when creating chatbots.

================================================================================

## Why BuilderBot? - BuilderBot.app Chatbot for Whatsapp, Telegram and more
URL: https://builderbot.vercel.app/concepts
Section: General
Importance: 0.60
Description: In this guide, we will talk about what happens when something goes wrong while you work with the API.

Why BuilderBot? BuilderBot is the framework for the creation of ChatBots focused on low-frequency communication channels, whatsapp, telegram, etc. We implement an architecture focused on improving the developer experience and the reuse of logic at all times, if you need to create chatbots for whatsapp quickly, without limits and easy connection between different providers then BuilderBot is for you. The library is based on three key components for its correct functioning: the Flow, in charge of building the context of the conversation and offering a friendly interface to the developer; the Provider, which acts as a connector allowing to easily switch between WhatsApp providers without the risk of affecting other parts of the bot; and the Database, which in line with this connector philosophy, facilitates changing the data persistence layer without the need to rewrite the workflow. Flow Refers to creating structured sequences of interactions, as in building conversation flows. Two key methods are addKeyword and addAnswer, which allow keywords to be associated with specific responses, providing options for customizing the conversation flow. Keywords are the words you will use to start the flow, you can use a single word or a list of words. Example "hello", "good morning". app.tsapp.jsimport { addKeyword } from '@builderbot/bot' addKeyword(['hello','hi']).addAnswer('Ey! welcome') CopyCopied! Some examples of how to use the addKeyword in which you can place the keyword or a list of keywords that will be used to start a conversational flow // Example with single keyword addKeyword('hello').addAnswer('Ey! welcome') // Example with multi keywords addKeyword(['hello','hi']).addAnswer('Ey! welcome') CopyCopied! For a quick understanding of the operation we have prepared a basic example of how to implement View more examples Provider It is a key piece used to deliver the message to the chosen supplier. In a case you are building a bot for whatsapp you should use an adapter like Meta, Twilio, Baileys, etc or even if you want to connect to Telegram. app.tsprovider.wppconnect.tsprovider.meta.tsimport { addKeyword, MemoryDB, createProvider, createFlow } from '@builderbot/bot' import { BaileysProvider } from '@builderbot/provider-baileys' // ...stuff code... const main = async () => { await createBot({ database: new MemoryDB(), provider: createProvider(BaileysProvider), flow: createFlow([flowDemo]) }) } main() CopyCopied! More information about the providers Database Just as providers can be easily exchanged between adapters, we can do the same with the database. Now the important thing to understand is how it works. The main purpose of the database inside the bot is to provide the bot with a record of the different events that have occurred between different conversations. It is ready to implement adapters from Mongo, MySQL, Postgres, among others. app.tsprovider.wppconnect.tsprovider.meta.tsimport { addKeyword, MemoryDB, createProvider, createFlow } from '@builderbot/bot' import { BaileysProvider } from '@builderbot/provider-baileys' // ...stuff code... const main = async () => { await createBot({ database: new MemoryDB(), provider: createProvider(BaileysProvider), flow: createFlow([flowDemo]) }) } main() CopyCopied! More information about the databases GuidesMy first chatbotLearn how build your first chatbot in few minutesRead moreConceptsUnderstand the essential concepts for building botsRead moreAdd FunctionsThe key to learning how to write flows is add-functions.Read morePluginsUnlimitate and start implementing the community plugins.Read more ResourcesModularizeLearn how to modularise flows so that you can have a more maintainable bot.Send MessageHow to send a message via HTTP to start conversations, you can send multimedia as well.DockerizerA good practice is to dockerise your bots to make them more maintainable and effective.EventsLearning about events will make us more fluent when creating chatbots.

================================================================================

## Telegram - BuilderBot.app Chatbot for Whatsapp, Telegram and more
URL: https://builderbot.vercel.app/en/plugins/telegram#guides
Section: Getting Started
Importance: 0.60
Description: Telegram is a user-friendly provider, in this article you will learn how to integrate your Telegram bots with the library.

Telegram Create your first Telegram bot if you don't have one yet create your firts Telegram bot Implementing a new communication channel such as telegram without affecting the logic of your project is very simple. Below you can find the starting point to implement the new telegram provider. Install pnpmnpm pnpm install @builderbot-plugins/telegram CopyCopied! import { createBot, MemoryDB, createProvider, addKeyword, createFlow } from '@builderbot/bot' import { TelegramProvider } from '@builderbot-plugins/telegram' const welcomeFlow = addKeyword(['hi']) .addAnswer('Ey! welcome') .addAnswer('Your name is?', { capture: true }, async (ctx, { flowDynamic }) => { await flowDynamic([`nice! ${ctx.body}`,'I will send you a funny image']) }) .addAction(async(_ , {flowDynamic}) => { const dataApi = await fetch(`https://shibe.online/api/shibes?count=1&urls=true&httpsUrls=true`) const [imageUrl] = await dataApi.json() await flowDynamic([{body:'😜', media: imageUrl}]) }) const main = async () => { const adapterDB = new MemoryDB() const adapterFlow = createFlow([welcomeFlow]) const adapterProvider = createProvider(TelegramProvider, { token: 'YOUR_TELEGRAM_TOKEN_HERE' }) await createBot({ flow: adapterFlow, provider: adapterProvider, database: adapterDB, }) } main() CopyCopied! In this way we have already implemented a new provider for Telegram keeping the same logic. GuidesMy first chatbotLearn how build your first chatbot in few minutesRead moreConceptsUnderstand the essential concepts for building botsRead moreAdd FunctionsThe key to learning how to write flows is add-functions.Read morePluginsUnlimitate and start implementing the community plugins.Read more ResourcesModularizeLearn how to modularise flows so that you can have a more maintainable bot.Send MessageHow to send a message via HTTP to start conversations, you can send multimedia as well.DockerizerA good practice is to dockerise your bots to make them more maintainable and effective.EventsLearning about events will make us more fluent when creating chatbots.

================================================================================

## CONTRIBUTING - BuilderBot.app Chatbot for Whatsapp, Telegram and more
URL: https://builderbot.vercel.app/plugins
Section: General
Importance: 0.60
Description: Contributing with us, join and coding side to side a great community

CONTRIBUTING Welcome We're glad that you're interested in contributing to our project! Here you will find all the necessary information to start collaborating. You can contribute in various ways, whether it's updating the documentation, improving the code, reviewing pending issues in the issues, or even making financial contributions, which will be used for various purposes related to the development and maintenance of the project. You can see more details on how to make financial contributions here. The main language we use in this project is TypeScript, which allows us to maintain readable and scalable code. Frequent Questions Here are some answers to frequently asked questions that may arise when contributing to the project: What is Lerna? You can find an explanation in this video. How do I make commits effectively? Here's a video that shows you how to do it. What are our communication channels? You can join our community on Discord. Requirements: Before starting to contribute to the project, make sure you have the following tools installed: Node.js: Version 18 or higher. You can download Node from here. pnpm: Package manager. You can install it by following the instructions here. VSCode: Code editor that we recommend, as it has useful plugins. Conventional Commits: VSCode plugin that helps you create semantic commits, following best practices. You can install it from here. Get Starter Make a fork Before starting work on the project, fork it to your own GitHub account. This will allow you to work on your own copy of the repository. Click on the following link to fork: here. Clone the Repository (from your fork) Once you have forked the project, clone your own copy of the repository using the following command in your terminal: git clone https://github.com/TU_USERNAME/bot-plugins CopyCopied! Dependencies install Go to the project folder and run the following commands to install the necessary dependencies: cd bot-plugins pnpm install pnpm run build CopyCopied! Create a new integration To create a new integration, run the following command in your terminal: pnpm run create.package <package_name> CopyCopied! compile (build) To compile the application, run the following command in your terminal. This will generate a dist directory within the monorepo packages. npx lerna run build --scope=<package_name> CopyCopied! tests environments Once you have run the build and everything is correct, run the following command in your terminal: pnpm run copy.lib CopyCopied! This command will copy the necessary files into the base_app folder. Make sure you have previously run npm install within the base_app folder. Then, from the root of your directory, run: pnpm run copy.lib CopyCopied! To start the assistant, run: npm run dev CopyCopied! It should work smoothly. Test End-to-End (E2E) All changes made must pass the end-to-end tests. These tests are run with the following command: pnpm run test CopyCopied! Make sure you have a test folder and files with the .test.ts extension for your tests.

================================================================================

## Events - BuilderBot.app Chatbot for Whatsapp, Telegram and more
URL: https://builderbot.vercel.app/events
Section: General
Importance: 0.60
Description: In this guide, we will talk about what happens when something goes wrong while you work with the API.

Events Sometimes users send messages such as an image, a video or special location messages, among others, to receive and start a conversation when a message of this type arrives we can use the events. WELCOMEDefault When a user sends a "text" message that does not exist in a keyword on another flow, the WELCOME event will be triggered by default, which is the default event. Let's imagine the case in which a person writes the word Thank you! app.tsapp.js import { addKeyword, EVENTS } from '@builderbot/bot' const welcomeFlow = addKeyword(EVENTS.WELCOME).addAnswer('Ey welcome?') const greetingFlow = addKeyword(['hello','hi']).addAnswer('Hi!') CopyCopied! We can see in the diagram above that the bot does a search in all the flows to get the best flow that can respond to the keyword "Thank You" but as it does not find then the "WELCOME" is triggered. MEDIAReceived Image or Video When a user sends an image or a video, the MEDIA event, which is the default event, will be triggered by default. This is ideal for when we need them to send information and we need to store it. app.tsapp.js import { addKeyword, EVENTS } from '@builderbot/bot' const mediaFlow = addKeyword(EVENTS.MEDIA).addAnswer('I received a media image/video') CopyCopied! To save the media file you must invoke the saveFile function from the provider you are using. app.tsapp.js import { addKeyword, EVENTS } from '@builderbot/bot' import { BaileysProvider } from '@builderbot/provider-baileys' const mediaFlow = addKeyword<BaileysProvider>(EVENTS.MEDIA) .addAnswer('I received a media image/video', async (ctx, { provider }) => { const localPath = await provider.saveFile(ctx, {path:'...'}) //console.log(localPath) }) CopyCopied! DOCUMENTReceived Document When a user sends a document, DOCUMENT event will be triggered by default, which is the default event. app.tsapp.js import { addKeyword, EVENTS } from '@builderbot/bot' const documentFlow = addKeyword(EVENTS.DOCUMENT) .addAnswer("Wow! I'm sorry I can't read this document right now", async (ctx, { provider }) => { const localPath = await provider.saveFile(ctx, {path:'...'}) //console.log(localPath) }) CopyCopied! LOCATIONReceived Location Location must be sent via WhatsApp, does not yet allow location links from external apps When your chatbot needs to access a user's location, it's important to ensure that the location is sent directly from the WhatsApp app to have results. Once the location is received, you can perform a console log of ctx to view the details of the received location. The received location context will look something like this in console: ctx: { ... message: Message { locationMessage: LocationMessage { degreesLatitude: -2.1462137699127197, degreesLongitude: -79.88981628417969, name: 'Doctor Miguel Angel Jijón Teran', address: 'Doctor Miguel Angel Jijón Teran, Guayaquil, Ecuador', }, }, body: '_event_location__0d5c9f57-0909-44a1-995f-902f9df3b21f', name: 'yeyodev 👨🏾‍💻', from: '593000000000' } CopyCopied! This will output the user's latitude and longitude in the console, allowing you to effectively utilize the location data for your chatbot's functionality. To access the location data, you can use the following approach: location.flow.tslocation.flow.jsimport { EVENTS, addKeyword } from "@builderbot/bot"; export default addKeyword(EVENTS.LOCATION) .addAnswer("I have received your location!", null, async (ctx) => { const userLatitude = ctx.message.locationMessage.degreesLatitude; const userLongitude = ctx.message.locationMessage.degreesLongitude; }) CopyCopied! VOICE_NOTEReceived Voice Note When a user sends a voice note, the VOICE_NOTE event will be triggered by default, which is the event intended for this behavior, it is important to understand that a voice note is different from an image or video file. app.tsapp.js import { addKeyword, EVENTS } from '@builderbot/bot' const voiceNoteFlow = addKeyword(EVENTS.VOICE_NOTE) .addAnswer('Give me a second to hear you!', async (ctx, { provider }) => { const localPath = await provider.saveFile(ctx, {path:'...'}) //console.log(localPath) }) CopyCopied! GuidesMy first chatbotLearn how build your first chatbot in few minutesRead moreConceptsUnderstand the essential concepts for building botsRead moreAdd FunctionsThe key to learning how to write flows is add-functions.Read morePluginsUnlimitate and start implementing the community plugins.Read more ResourcesModularizeLearn how to modularise flows so that you can have a more maintainable bot.Send MessageHow to send a message via HTTP to start conversations, you can send multimedia as well.DockerizerA good practice is to dockerise your bots to make them more maintainable and effective.EventsLearning about events will make us more fluent when creating chatbots.

================================================================================

## Examples - BuilderBot.app Chatbot for Whatsapp, Telegram and more
URL: https://builderbot.vercel.app/en/uses-cases#guides
Section: Getting Started
Importance: 0.60
Description: In this guide, we will talk about what happens when something goes wrong while you work with the API.

Examples Below you will find different examples showing the implementation in different use cases. These examples have been compiled based on the community, feel free to post an example that you like or that you think would be useful for new people. How to Update to the Latest Version To ensure you're using the most up-to-date features and bug fixes, it's important to keep your BuilderBot installation current. Follow the steps below to update to the latest version. To keep your project up to date, make sure to run the command to update the core and the corresponding provider pnpm install @builderbot/bot@latest pnpm install @builderbot/provider-baileys@latest pnpm install @builderbot/provider-wppconnect@latest pnpm install @builderbot/provider-venom@latest pnpm install @builderbot/provider-meta@latest pnpm install @builderbot/provider-twilio@latest CopyCopied! My first bot The following code represents the quick use of a bot that when you type the word hi, greets you with a welcome message and asks you for your name and then returns a funny image app.tsimport { createBot, createProvider, createFlow, addKeyword, MemoryDB } from '@builderbot/bot' import { BaileysProvider } from '@builderbot/provider-baileys' const welcomeFlow = addKeyword<BaileysProvider, MemoryDB>(['hi']) .addAnswer('Ey! welcome') .addAnswer('Your name is?', { capture: true }, async (ctx, { flowDynamic }) => { await flowDynamic([`nice! ${ctx.body}`,'I will send you a funny image']) }) .addAction(async(_ , {flowDynamic}) => { const dataApi = await fetch(`https://shibe.online/api/shibes?count=1&urls=true&httpsUrls=true`) const [imageUrl] = await dataApi.json() await flowDynamic([{body:'😜', media: imageUrl}]) }) const main = async () => { const adapterDB = new MemoryDB() const adapterFlow = createFlow([welcomeFlow]) const adapterProvider = createProvider(BaileysProvider) adapterProvider.initHttpServer(3000) await createBot({ flow: adapterFlow, provider: adapterProvider, database: adapterDB, }) } main() CopyCopied! stateConversational history Often, we will need to manage conversations and keep the context in a memory called state which is volatile and accessible from any function executed in a stream. const welcomeFlow = addKeyword(['hello']) .addAnswer( "¿What's your name?", {capture: true}, async (ctx, { flowDynamic, state }) => { await state.update({ name: ctx.body }) await flowDynamic('Thanks for giving me your name!') } ) .addAnswer( '¿How old are you?', {capture: true}, async (ctx, { flowDynamic, state }) => { const name = state.get('name') await state.update({ age: ctx.body }) await flowDynamic(`Thanks for sharing your age! ${name}`) } ) .addAnswer('Here is your data:', null, async (_, { flowDynamic, state }) => { const myState = state.getMyState() await flowDynamic(`Name: ${myState.name} Age: ${myState.age}`) }) CopyCopied! flowDynamicDynamic Messages In other occasions we need to send messages in a dynamic way of data that can be variable, below you can see an example of how you should do it and how you should NOT do it. ❌ Avoid it this, does not work because addAnswer serializes the content at the start of execution. let name = '' const flow = addKeyword('hello') .addAnswer(`What is your name?`, { capture: true }, async (ctx) => { name = ctx.body }) .addAnswer(`Your name is: ${name}`) CopyCopied! If you want to send a dynamic message use flowDynamic. const flow = addKeyword('hello') .addAnswer(`What is your name?`, { capture: true }, async (ctx, { state }) => { await state.update({ name: ctx.body }) }) .addAction(async (ctx, { state, flowDynamic }) => { const name = state.get('name') await flowDynamic(`Your name is: ${name}`) }) CopyCopied! Send File When you want to send an image, audio, file or any other file you can do it this way. It is important to note that the URL must be publicly accessible. const flow = addKeyword('hello') .addAnswer(`Send image from URL`, { media: 'https://i.imgur.com/0HpzsEm.png' } ) .addAnswer(`Send video from Local`, { media: join(process.cwd(), 'assets', 'sample.png') } ) .addAnswer(`Send video from URL`, { media: 'https://media.giphy.com/media/KWZKwdBC2ODWlQ8kgt/giphy.mp4' } ) .addAnswer(`Send file from URL`, { media: 'https://www.w3.org/WAI/ER/tests/xhtml/testfiles/resources/pdf/dummy.pdf' } ) CopyCopied! Other ways to use when the route is coming from a dynamic data source const flow = addKeyword('hello') .addAction(async (_,{flowDynamic}) => { // ...db get source... await flowDynamic([ {body:'This is an image', media:'https://i.imgur.com/0HpzsEm.png'} ]) await flowDynamic([ {body:'This is a video', media:'https://media.giphy.com/media/KWZKwdBC2ODWlQ8kgt/giphy.mp4'} ]) }) CopyCopied! If you need to send a file that is stored locally you can do that too. The use of join is recommended to ensure correct directory concatenation. const flow = addKeyword('hello') .addAction(async (_,{flowDynamic}) => { const pathLocal = join('assets','doc.pdf') // pathLocal = c:/doc.pdf await flowDynamic([ {body:'This is a video', media: pathLocal } ]) }) CopyCopied! gotoFlowSwitch to another flow If you want to divert a conversational flow to another logic flow based on a response input you can do it in this way: const flowToA = addKeyword(EVENTS.ACTION).addAnswer('Here we have Option A!') const flowToB = addKeyword(EVENTS.ACTION).addAnswer('Here we have Option B!') const flowToC = addKeyword(EVENTS.ACTION).addAnswer('Here we have Option C!') const flowDefault = addKeyword(EVENTS.ACTION).addAnswer("We don't have that Option 🤔") const flow = addKeyword('order') .addAnswer( [ `Which one is the best option for you?`, `Type **A**`, `Type **B**`, `Type **C**`, ], { capture: true } ) .addAnswer(`Thanks for you answer`,async (ctx, {gotoFlow})=> { const userAnswer = ctx.body if(userAnswer === 'A'){ return gotoFlow(flowToA) } if(userAnswer === 'B'){ return gotoFlow(flowToB) } if(userAnswer === 'C'){ return gotoFlow(flowToC) } return gotoFlow(flowDefault) }) .addAnswer(`this message will not be sent`) CopyCopied! ❌ This does not work, the invocation of the gotoFlow function must necessarily include a return. //...Previous code... ....addAnswer(`Thanks for you answer`,async (ctx, {gotoFlow})=> { gotoFlow(flowToA) }) .addAnswer(`this message will not be sent`) CopyCopied! This does work //...Previous code... ....addAnswer(`Thanks for you answer`,async (ctx, {gotoFlow})=> { return gotoFlow(flowToA) }) .addAnswer(`this message will not be sent`) CopyCopied! stateTurn off bot a certain user Sometimes we will need to turn off the bot for a certain user, so that we can have a conversation with the client without the bot interfering. const flow = addKeyword<BaileysProvider>('magic keyword') .addAction(async (_, { state, endFlow }) => { const botOffForThisUser = state.get<boolean>('botOffForThisUser') await state.update({botOffForThisUser:!botOffForThisUser}) if(botOffForThisUser) return endFlow() }) .addAnswer('Hello!') CopyCopied! stateTurn off for everyone Sometimes we will need to disable the bot for all people, without the need to shut down the server or stop the script. const flow = addKeyword<BaileysProvider>('botoff') .addAction(async (_, { globalState, endFlow }) => { const botOffForEveryOne = globalState.get<boolean>('botOffForEveryOne') await globalState.update({botOffForEveryOne:!botOffForEveryOne}) if(botOffForEveryOne) return endFlow() }) .addAnswer('Hello!') CopyCopied! stateBot Self-Interaction In certain scenarios, it is necessary for the bot's phone number (host) to be able to interact within logical flows. To achieve this, we have several configurable options: host: This is used when you want the bot to be able to respond to messages in the same chat with itself. For example, if the bot's number is 0000, it will be able to send and receive messages to/from 0000. both: This option allows both the bot and you (the developer/administrator) to intervene in the chat of a person interacting with the bot. none: (default option) Only allows interaction between the user and the bot, without intervention from the host number. app.tsimport { createBot, createProvider, createFlow, addKeyword, MemoryDB } from '@builderbot/bot' import { BaileysProvider } from '@builderbot/provider-baileys' const main = async () => { const adapterDB = new MemoryDB() const adapterFlow = createFlow([...]) const adapterProvider = createProvider(BaileysProvider, { writeMyself: 'host' as 'none' | 'host' | 'both' }) adapterProvider.initHttpServer(3000) await createBot({ flow: adapterFlow, provider: adapterProvider, database: adapterDB, }) } main() CopyCopied! GuidesMy first chatbotLearn how build your first chatbot in few minutesRead moreConceptsUnderstand the essential concepts for building botsRead moreAdd FunctionsThe key to learning how to write flows is add-functions.Read morePluginsUnlimitate and start implementing the community plugins.Read more ResourcesModularizeLearn how to modularise flows so that you can have a more maintainable bot.Send MessageHow to send a message via HTTP to start conversations, you can send multimedia as well.DockerizerA good practice is to dockerise your bots to make them more maintainable and effective.EventsLearning about events will make us more fluent when creating chatbots.

================================================================================

## Telegram - BuilderBot.app Chatbot for Whatsapp, Telegram and more
URL: https://builderbot.vercel.app/plugins/telegram
Section: General
Importance: 0.50
Description: Telegram is a user-friendly provider, in this article you will learn how to integrate your Telegram bots with the library.

Telegram Create your first Telegram bot if you don't have one yet create your firts Telegram bot Implementing a new communication channel such as telegram without affecting the logic of your project is very simple. Below you can find the starting point to implement the new telegram provider. Install pnpmnpm pnpm install @builderbot-plugins/telegram CopyCopied! import { createBot, MemoryDB, createProvider, addKeyword, createFlow } from '@builderbot/bot' import { TelegramProvider } from '@builderbot-plugins/telegram' const welcomeFlow = addKeyword(['hi']) .addAnswer('Ey! welcome') .addAnswer('Your name is?', { capture: true }, async (ctx, { flowDynamic }) => { await flowDynamic([`nice! ${ctx.body}`,'I will send you a funny image']) }) .addAction(async(_ , {flowDynamic}) => { const dataApi = await fetch(`https://shibe.online/api/shibes?count=1&urls=true&httpsUrls=true`) const [imageUrl] = await dataApi.json() await flowDynamic([{body:'😜', media: imageUrl}]) }) const main = async () => { const adapterDB = new MemoryDB() const adapterFlow = createFlow([welcomeFlow]) const adapterProvider = createProvider(TelegramProvider, { token: 'YOUR_TELEGRAM_TOKEN_HERE' }) await createBot({ flow: adapterFlow, provider: adapterProvider, database: adapterDB, }) } main() CopyCopied! In this way we have already implemented a new provider for Telegram keeping the same logic. GuidesMy first chatbotLearn how build your first chatbot in few minutesRead moreConceptsUnderstand the essential concepts for building botsRead moreAdd FunctionsThe key to learning how to write flows is add-functions.Read morePluginsUnlimitate and start implementing the community plugins.Read more ResourcesModularizeLearn how to modularise flows so that you can have a more maintainable bot.Send MessageHow to send a message via HTTP to start conversations, you can send multimedia as well.DockerizerA good practice is to dockerise your bots to make them more maintainable and effective.EventsLearning about events will make us more fluent when creating chatbots.

================================================================================

## Examples - BuilderBot.app Chatbot for Whatsapp, Telegram and more
URL: https://builderbot.vercel.app/uses-cases
Section: Examples
Importance: 0.50
Description: In this guide, we will talk about what happens when something goes wrong while you work with the API.

Examples Below you will find different examples showing the implementation in different use cases. These examples have been compiled based on the community, feel free to post an example that you like or that you think would be useful for new people. How to Update to the Latest Version To ensure you're using the most up-to-date features and bug fixes, it's important to keep your BuilderBot installation current. Follow the steps below to update to the latest version. To keep your project up to date, make sure to run the command to update the core and the corresponding provider pnpm install @builderbot/bot@latest pnpm install @builderbot/provider-baileys@latest pnpm install @builderbot/provider-wppconnect@latest pnpm install @builderbot/provider-venom@latest pnpm install @builderbot/provider-meta@latest pnpm install @builderbot/provider-twilio@latest CopyCopied! My first bot The following code represents the quick use of a bot that when you type the word hi, greets you with a welcome message and asks you for your name and then returns a funny image app.tsimport { createBot, createProvider, createFlow, addKeyword, MemoryDB } from '@builderbot/bot' import { BaileysProvider } from '@builderbot/provider-baileys' const welcomeFlow = addKeyword<BaileysProvider, MemoryDB>(['hi']) .addAnswer('Ey! welcome') .addAnswer('Your name is?', { capture: true }, async (ctx, { flowDynamic }) => { await flowDynamic([`nice! ${ctx.body}`,'I will send you a funny image']) }) .addAction(async(_ , {flowDynamic}) => { const dataApi = await fetch(`https://shibe.online/api/shibes?count=1&urls=true&httpsUrls=true`) const [imageUrl] = await dataApi.json() await flowDynamic([{body:'😜', media: imageUrl}]) }) const main = async () => { const adapterDB = new MemoryDB() const adapterFlow = createFlow([welcomeFlow]) const adapterProvider = createProvider(BaileysProvider) adapterProvider.initHttpServer(3000) await createBot({ flow: adapterFlow, provider: adapterProvider, database: adapterDB, }) } main() CopyCopied! stateConversational history Often, we will need to manage conversations and keep the context in a memory called state which is volatile and accessible from any function executed in a stream. const welcomeFlow = addKeyword(['hello']) .addAnswer( "¿What's your name?", {capture: true}, async (ctx, { flowDynamic, state }) => { await state.update({ name: ctx.body }) await flowDynamic('Thanks for giving me your name!') } ) .addAnswer( '¿How old are you?', {capture: true}, async (ctx, { flowDynamic, state }) => { const name = state.get('name') await state.update({ age: ctx.body }) await flowDynamic(`Thanks for sharing your age! ${name}`) } ) .addAnswer('Here is your data:', null, async (_, { flowDynamic, state }) => { const myState = state.getMyState() await flowDynamic(`Name: ${myState.name} Age: ${myState.age}`) }) CopyCopied! flowDynamicDynamic Messages In other occasions we need to send messages in a dynamic way of data that can be variable, below you can see an example of how you should do it and how you should NOT do it. ❌ Avoid it this, does not work because addAnswer serializes the content at the start of execution. let name = '' const flow = addKeyword('hello') .addAnswer(`What is your name?`, { capture: true }, async (ctx) => { name = ctx.body }) .addAnswer(`Your name is: ${name}`) CopyCopied! If you want to send a dynamic message use flowDynamic. const flow = addKeyword('hello') .addAnswer(`What is your name?`, { capture: true }, async (ctx, { state }) => { await state.update({ name: ctx.body }) }) .addAction(async (ctx, { state, flowDynamic }) => { const name = state.get('name') await flowDynamic(`Your name is: ${name}`) }) CopyCopied! Send File When you want to send an image, audio, file or any other file you can do it this way. It is important to note that the URL must be publicly accessible. const flow = addKeyword('hello') .addAnswer(`Send image from URL`, { media: 'https://i.imgur.com/0HpzsEm.png' } ) .addAnswer(`Send video from Local`, { media: join(process.cwd(), 'assets', 'sample.png') } ) .addAnswer(`Send video from URL`, { media: 'https://media.giphy.com/media/KWZKwdBC2ODWlQ8kgt/giphy.mp4' } ) .addAnswer(`Send file from URL`, { media: 'https://www.w3.org/WAI/ER/tests/xhtml/testfiles/resources/pdf/dummy.pdf' } ) CopyCopied! Other ways to use when the route is coming from a dynamic data source const flow = addKeyword('hello') .addAction(async (_,{flowDynamic}) => { // ...db get source... await flowDynamic([ {body:'This is an image', media:'https://i.imgur.com/0HpzsEm.png'} ]) await flowDynamic([ {body:'This is a video', media:'https://media.giphy.com/media/KWZKwdBC2ODWlQ8kgt/giphy.mp4'} ]) }) CopyCopied! If you need to send a file that is stored locally you can do that too. The use of join is recommended to ensure correct directory concatenation. const flow = addKeyword('hello') .addAction(async (_,{flowDynamic}) => { const pathLocal = join('assets','doc.pdf') // pathLocal = c:/doc.pdf await flowDynamic([ {body:'This is a video', media: pathLocal } ]) }) CopyCopied! gotoFlowSwitch to another flow If you want to divert a conversational flow to another logic flow based on a response input you can do it in this way: const flowToA = addKeyword(EVENTS.ACTION).addAnswer('Here we have Option A!') const flowToB = addKeyword(EVENTS.ACTION).addAnswer('Here we have Option B!') const flowToC = addKeyword(EVENTS.ACTION).addAnswer('Here we have Option C!') const flowDefault = addKeyword(EVENTS.ACTION).addAnswer("We don't have that Option 🤔") const flow = addKeyword('order') .addAnswer( [ `Which one is the best option for you?`, `Type **A**`, `Type **B**`, `Type **C**`, ], { capture: true } ) .addAnswer(`Thanks for you answer`,async (ctx, {gotoFlow})=> { const userAnswer = ctx.body if(userAnswer === 'A'){ return gotoFlow(flowToA) } if(userAnswer === 'B'){ return gotoFlow(flowToB) } if(userAnswer === 'C'){ return gotoFlow(flowToC) } return gotoFlow(flowDefault) }) .addAnswer(`this message will not be sent`) CopyCopied! ❌ This does not work, the invocation of the gotoFlow function must necessarily include a return. //...Previous code... ....addAnswer(`Thanks for you answer`,async (ctx, {gotoFlow})=> { gotoFlow(flowToA) }) .addAnswer(`this message will not be sent`) CopyCopied! This does work //...Previous code... ....addAnswer(`Thanks for you answer`,async (ctx, {gotoFlow})=> { return gotoFlow(flowToA) }) .addAnswer(`this message will not be sent`) CopyCopied! stateTurn off bot a certain user Sometimes we will need to turn off the bot for a certain user, so that we can have a conversation with the client without the bot interfering. const flow = addKeyword<BaileysProvider>('magic keyword') .addAction(async (_, { state, endFlow }) => { const botOffForThisUser = state.get<boolean>('botOffForThisUser') await state.update({botOffForThisUser:!botOffForThisUser}) if(botOffForThisUser) return endFlow() }) .addAnswer('Hello!') CopyCopied! stateTurn off for everyone Sometimes we will need to disable the bot for all people, without the need to shut down the server or stop the script. const flow = addKeyword<BaileysProvider>('botoff') .addAction(async (_, { globalState, endFlow }) => { const botOffForEveryOne = globalState.get<boolean>('botOffForEveryOne') await globalState.update({botOffForEveryOne:!botOffForEveryOne}) if(botOffForEveryOne) return endFlow() }) .addAnswer('Hello!') CopyCopied! stateBot Self-Interaction In certain scenarios, it is necessary for the bot's phone number (host) to be able to interact within logical flows. To achieve this, we have several configurable options: host: This is used when you want the bot to be able to respond to messages in the same chat with itself. For example, if the bot's number is 0000, it will be able to send and receive messages to/from 0000. both: This option allows both the bot and you (the developer/administrator) to intervene in the chat of a person interacting with the bot. none: (default option) Only allows interaction between the user and the bot, without intervention from the host number. app.tsimport { createBot, createProvider, createFlow, addKeyword, MemoryDB } from '@builderbot/bot' import { BaileysProvider } from '@builderbot/provider-baileys' const main = async () => { const adapterDB = new MemoryDB() const adapterFlow = createFlow([...]) const adapterProvider = createProvider(BaileysProvider, { writeMyself: 'host' as 'none' | 'host' | 'both' }) adapterProvider.initHttpServer(3000) await createBot({ flow: adapterFlow, provider: adapterProvider, database: adapterDB, }) } main() CopyCopied! GuidesMy first chatbotLearn how build your first chatbot in few minutesRead moreConceptsUnderstand the essential concepts for building botsRead moreAdd FunctionsThe key to learning how to write flows is add-functions.Read morePluginsUnlimitate and start implementing the community plugins.Read more ResourcesModularizeLearn how to modularise flows so that you can have a more maintainable bot.Send MessageHow to send a message via HTTP to start conversations, you can send multimedia as well.DockerizerA good practice is to dockerise your bots to make them more maintainable and effective.EventsLearning about events will make us more fluent when creating chatbots.

================================================================================

## Modularize Flows - BuilderBot.app Chatbot for Whatsapp, Telegram and more
URL: https://builderbot.vercel.app/showcases/modularize
Section: General
Importance: 0.50
Description: Implement message queues for better resource management

Modularize Flows Issue My application grew so large that I was having trouble maintaining it and the code was becoming spaghetti code. Possible Solution As our projects grow we will need to implement a better way to maintain the project, in this case it is highly recommended to implement a module view. In the following example we will show how we have migrated the modules to a directory, as well as the provider and the database. app.tsprovider/index.tsdatabase/index.tsflow/index.tsflow/welcome.flow.tsservices/ai.ts import { createBot } from '@builderbot/bot'; import { flow } from "./flow"; import { database } from "./database"; import { provider } from "./provider"; import { ai } from "./services/ai"; const main = async () => { await createBot({ flow, provider, database, }, extensions: { ai // Dependency AI }) provider.initHttpServer(3000) } main() CopyCopied! An example of the scaffolding you can use in your project. Or a more user friendly folder structure. structuresrc ├── app.ts ├── database │ └── index.ts ├── flow │ ├── index.ts │ └── welcome.flow.ts │ └── bye.flow.ts │ └── media.flow.ts ├── provider │ └── index.ts └── services └── ai.ts CopyCopied! GuidesMy first chatbotLearn how build your first chatbot in few minutesRead moreConceptsUnderstand the essential concepts for building botsRead moreAdd FunctionsThe key to learning how to write flows is add-functions.Read morePluginsUnlimitate and start implementing the community plugins.Read more ResourcesModularizeLearn how to modularise flows so that you can have a more maintainable bot.Send MessageHow to send a message via HTTP to start conversations, you can send multimedia as well.DockerizerA good practice is to dockerise your bots to make them more maintainable and effective.EventsLearning about events will make us more fluent when creating chatbots.

================================================================================

## Deploy - BuilderBot.app Chatbot for Whatsapp, Telegram and more
URL: https://builderbot.vercel.app/deploy/docker
Section: General
Importance: 0.50
Description: In this guide, we will discuss how to create a Dockerfile and how to deploy your bot.

Deploy Previously, you need to have Docker installed on your server depending on the operating system, the processes change, you can find all the official information about docker at this link. Depending on the provider you have chosen, you will need a specific Docker implementation, but don't worry, as it comes automatically implemented in a file called Dockerfile, you can also view the other Dockerfiles in the templates section. Dockerfile, Build Image, Run Container, Portainer Dockerfile# THIS IS THE BASE IMAGE FOR THE BOT FROM node:21-alpine3.18 as builder # Enable Corepack and prepare for PNPM installation to increase performance RUN corepack enable && corepack prepare pnpm@latest --activate ENV PNPM_HOME=/usr/local/bin # Set the working directory WORKDIR /app # Copy package.json and pnpm-lock.yaml files to the working directory COPY package*.json pnpm-lock.yaml ./ # Install dependencies using PNPM COPY . . RUN pnpm i # Create a new stage for deployment FROM builder as deploy # Copy only necessary files and directories for deployment COPY --from=builder /app/src ./src COPY --from=builder /app/package.json /app/pnpm-lock.yaml ./ RUN pnpm install CMD ["pnpm", "start"] CopyCopied! Build Image In this step, we are going to build the Docker image with all the settings of your project, remember that depending on the libraries you are using, you may need to modify the Dockerfile for it to function correctly. Build Imagedocker build . -t builderbot:latest CopyCopied! You can see in your console that the image starts to build and the process logs are coming out, you must ensure that it ends with naming to docker.io/library/builderbot:latest => [internal] load build definition from Dockerfile 0.4s => [internal] load metadata for docker.io/library/node:21-alpine3.18 3.6s => .................... => => naming to docker.io/library/builderbot:latest CopyCopied! Run Container To run your containerized image by passing different environment variables depending on the configuration needed, you can do it in the following way. Remember to release the corresponding ports in your server's firewall. Example 3008 Run Container FullRun Container Quickdocker rm -f bot 2>/dev/null docker run \ --name "bot" \ --env OPENAI_API_KEY="your_api_key_value" \ --env PORT=3008 \ -p 3008:3008/tcp \ -v "$(pwd)/bot_sessions:/app/bot_sessions:rw" \ --cap-add SYS_ADMIN \ --restart always \ builderbot:latest CopyCopied! CommandExplanationdocker rm -f bot 2>/dev/nullDeletes any running container named "bot", if it exists. The 2>/dev/null redirects any error message to nothing, meaning if the container doesn't exist, no error message will be displayed.docker run -dStarts a new Docker container in detached mode (in the background).--name "bot"Assigns the name "amazing-bot" to the container.--env OPENAI_API_KEY="API"Sets the environment variable OPENAI_API_KEY inside the container to the provided value, which should be a valid API key to access OpenAI.--user $(id -u):$(id -g)Specifies the user and group under which the process will run inside the container. $(id -u) gets the current user ID of the system and $(id -g) gets the current group ID.-p 3008:3008/tcpPublishes port 3008 of the container to port 3008 of the host, allowing traffic to be directed to the container's port.-v $(pwd)/bot_sessions:/app/bot_sessions:rwMounts the host directory /root/sessions/bot_sessions to the container directory /app/bot_sessions with read-write permissions (rw).--cap-add SYS_ADMINGrants the container the SYS_ADMIN capability, providing a broad set of system administration capabilities.--restart alwaysConfigures the container to restart automatically if it stops or encounters an error.builderbot:latestSpecifies the Docker image to be used for creating and running the container. In this case, builderbot:latest is the image tag. Portainer If you are already familiar with docker and want to manage different bots mounted in containers a good OpenSource option is portainer. Portainer Community Edition is a user-friendly platform tailored for managing containerized applications across various environments like Docker, Swarm, Kubernetes, and ACI. With its straightforward deployment and intuitive interface, it simplifies the management of container resources such as images, volumes, and networks through a graphical interface or an API. Portainer operates within a single container, adaptable to both Linux and Windows environments. List of bots

================================================================================

## Why BuilderBot? - BuilderBot.app Chatbot for Whatsapp, Telegram and more
URL: https://builderbot.vercel.app/en/concepts#flow
Section: General
Importance: 0.50
Description: In this guide, we will talk about what happens when something goes wrong while you work with the API.

Why BuilderBot? BuilderBot is the framework for the creation of ChatBots focused on low-frequency communication channels, whatsapp, telegram, etc. We implement an architecture focused on improving the developer experience and the reuse of logic at all times, if you need to create chatbots for whatsapp quickly, without limits and easy connection between different providers then BuilderBot is for you. The library is based on three key components for its correct functioning: the Flow, in charge of building the context of the conversation and offering a friendly interface to the developer; the Provider, which acts as a connector allowing to easily switch between WhatsApp providers without the risk of affecting other parts of the bot; and the Database, which in line with this connector philosophy, facilitates changing the data persistence layer without the need to rewrite the workflow. Flow Refers to creating structured sequences of interactions, as in building conversation flows. Two key methods are addKeyword and addAnswer, which allow keywords to be associated with specific responses, providing options for customizing the conversation flow. Keywords are the words you will use to start the flow, you can use a single word or a list of words. Example "hello", "good morning". app.tsapp.jsimport { addKeyword } from '@builderbot/bot' addKeyword(['hello','hi']).addAnswer('Ey! welcome') CopyCopied! Some examples of how to use the addKeyword in which you can place the keyword or a list of keywords that will be used to start a conversational flow // Example with single keyword addKeyword('hello').addAnswer('Ey! welcome') // Example with multi keywords addKeyword(['hello','hi']).addAnswer('Ey! welcome') CopyCopied! For a quick understanding of the operation we have prepared a basic example of how to implement View more examples Provider It is a key piece used to deliver the message to the chosen supplier. In a case you are building a bot for whatsapp you should use an adapter like Meta, Twilio, Baileys, etc or even if you want to connect to Telegram. app.tsprovider.wppconnect.tsprovider.meta.tsimport { addKeyword, MemoryDB, createProvider, createFlow } from '@builderbot/bot' import { BaileysProvider } from '@builderbot/provider-baileys' // ...stuff code... const main = async () => { await createBot({ database: new MemoryDB(), provider: createProvider(BaileysProvider), flow: createFlow([flowDemo]) }) } main() CopyCopied! More information about the providers Database Just as providers can be easily exchanged between adapters, we can do the same with the database. Now the important thing to understand is how it works. The main purpose of the database inside the bot is to provide the bot with a record of the different events that have occurred between different conversations. It is ready to implement adapters from Mongo, MySQL, Postgres, among others. app.tsprovider.wppconnect.tsprovider.meta.tsimport { addKeyword, MemoryDB, createProvider, createFlow } from '@builderbot/bot' import { BaileysProvider } from '@builderbot/provider-baileys' // ...stuff code... const main = async () => { await createBot({ database: new MemoryDB(), provider: createProvider(BaileysProvider), flow: createFlow([flowDemo]) }) } main() CopyCopied! More information about the databases GuidesMy first chatbotLearn how build your first chatbot in few minutesRead moreConceptsUnderstand the essential concepts for building botsRead moreAdd FunctionsThe key to learning how to write flows is add-functions.Read morePluginsUnlimitate and start implementing the community plugins.Read more ResourcesModularizeLearn how to modularise flows so that you can have a more maintainable bot.Send MessageHow to send a message via HTTP to start conversations, you can send multimedia as well.DockerizerA good practice is to dockerise your bots to make them more maintainable and effective.EventsLearning about events will make us more fluent when creating chatbots.

================================================================================

## Providers - BuilderBot.app Chatbot for Whatsapp, Telegram and more
URL: https://builderbot.vercel.app/providers
Section: General
Importance: 0.50
Description: In this guide, we will talk about what happens when something goes wrong while you work with the API.

Providers Providers are in charge of providing the communication bridge between your bot and whatsapp, telegram or custom provider. You can change your provider very easily without affecting the logic of your bot. It is as simple as implementing the connector of the provider of your choice. At the moment we have integrations with more than four suppliers. Whatsapp: Meta, Twilio, Baileys, WPPConnect, Venom, Telegram, Custom Provider Each provider may need to adjust access keys, settings, among other properties that are usually passed as an object in the createProvider function. meta-provider.tstwilio-provider.tsbaileys-provider.tsvenom-provider.tswppconnect-provider.tsimport { createProvider } from "@builderbot/bot"; import { MetaProvider } from '@builderbot/provider-meta'; export type IProvider = typeof MetaProvider export const adapterProvider = createProvider(MetaProvider, { jwtToken: 'jwtToken', numberId: 'numberId', verifyToken: 'verifyToken', version: 'v16.0', }) CopyCopied! Below you will find more information about each of these providers. Meta The WhatsApp Business Platform enables medium and large businesses to communicate with their customers on a large scale. You can initiate conversations with customers in just minutes, send them customer service notifications or purchase updates, offer them a personalized level of service, and provide support through the channel of their choice. meta-provider.tsapp.tsimport { createProvider } from "@builderbot/bot"; import { MetaProvider } from '@builderbot/provider-meta'; export type IProvider = typeof MetaProvider export const adapterProvider = createProvider(MetaProvider, { jwtToken: 'jwtToken', numberId: 'numberId', verifyToken: 'verifyToken', version: 'v16.0', }) CopyCopied! More info about Meta provider Twilio Twilio is a development platform that enables developers to build cloud communication applications and web systems. Twilio's communications APIs enable businesses to provide the right communication experience for their customers within web and mobile applications. By using Twilio APIs, developers can quickly add this functionality to an application, such as voice messaging, video calls, text messaging and more. twilio-provider.tsapp.tsimport { createProvider } from "@builderbot/bot"; import { TwilioProvider } from '@builderbot/provider-twilio'; export type IProvider = typeof TwilioProvider export const adapterProvider = createProvider(TwilioProvider, { accountSid: 'YOUR_ACCOUNT_SID', authToken: 'YOUR_ACCOUNT_TOKEN', vendorNumber: '+14155238886', publicUrl: "public_url", //optional }); CopyCopied! More info about Twilio provider Baileys Baileys is an open source project which allows sending messages, receiving messages and dozens of other features by implementing WebSocket in a version of whatsapp. It is a project with great trajectory driven by people with great knowledge of the subject, you can deepen in this library directly in its documentation or repository. Because this is a free provider that emulates the whatsapp web interface, you must scan the QR to log in. If you want to see more examples taking full advantage of this provider in conjunction with the builderbot library you can check this @jorgechavarriaga repository baileys-provider.tsbaileys-provider-extend.tsapp.tsimport { createProvider } from "@builderbot/bot"; import { BaileysProvider } from '@builderbot/provider-baileys'; export type IProvider = typeof BaileysProvider export const adapterProvider = createProvider(BaileysProvider) CopyCopied! Venom Venom is an open-source project that utilizes JavaScript to create high-performance bots for WhatsApp. It supports a wide range of interactions including customer care, media sending, AI-based phrase recognition, and various architectural designs tailored for WhatsApp. You can visit their official website as the repository to understand other features you can use. Because this is a free provider that emulates the whatsapp web interface, you must scan the QR to log in. venom-provider.tsvenom-provider-extend.tsapp.tsimport { createProvider } from "@builderbot/bot"; import { VenomProvider } from '@builderbot/provider-venom'; export type IProvider = typeof VenomProvider export const adapterProvider = createProvider(VenomProvider) CopyCopied! WPPConnect WPPConnect is an open source project developed by the JavaScript community with the aim of exporting functions from WhatsApp Web to the node, which can be used to support the creation of any interaction, such as customer service, media sending, intelligence recognition based on phrases artificial and many other things, use your imagination You can visit their official website as the repository to understand other features you can use. Because this is a free provider that emulates the whatsapp web interface, you must scan the QR to log in. wppconnect-provider.tswppconnect-provider-extend.tsapp.tsimport { createProvider } from "@builderbot/bot"; import { WPPConnectProvider } from '@builderbot/provider-wppconnect'; export type IProvider = typeof WPPConnectProvider export const adapterProvider = createProvider(WPPConnectProvider) CopyCopied! Wali.chat ProviderCustom Provider Custom provider there is the possibility to build your own customized adapter, we know that there are many more providers that can be very useful, an example can be Wali.chat which apart from giving us the possibility to interact via API Rest also offers a Dashboard to visualize and share data with your agents. app.tsprovider/wali.tsprovider/wali.events.tsimport { createBot, createProvider, createFlow, addKeyword, utils } from '@builderbot/bot' import { MemoryDB as Database } from '@builderbot/bot' import { WaliProvider as Provider } from './provider/wali' const PORT = process.env.PORT ?? 3008 const fullSamplesFlow = addKeyword<Provider, Database>(['samples', utils.setEvent('SAMPLES')]) .addAnswer(`💪 I'll send you a lot files...`) .addAnswer(`Send video from URL`, { media: 'https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExYTJ0ZGdjd2syeXAwMjQ4aWdkcW04OWlqcXI3Ynh1ODkwZ25zZWZ1dCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/LCohAb657pSdHv0Q5h/giphy.mp4' } ) .addAnswer(`Send audio from URL`, { media: 'https://cdn.freesound.org/previews/728/728142_11861866-lq.mp3' } ) .addAnswer(`Send file from URL`, { media: 'https://www.w3.org/WAI/ER/tests/xhtml/testfiles/resources/pdf/dummy.pdf' } ) const main = async () => { const adapterFlow = createFlow([fullSamplesFlow]) const adapterProvider = createProvider(Provider, { token: process.env.TOKEN, deviceId: process.env.DEVICE_ID }) const adapterDB = new Database() const { httpServer } = await createBot({ flow: adapterFlow, provider: adapterProvider, database: adapterDB, }) httpServer(+PORT) } main() CopyCopied!

================================================================================

## Databases - BuilderBot.app Chatbot for Whatsapp, Telegram and more
URL: https://builderbot.vercel.app/databases
Section: General
Importance: 0.50
Description: In this guide, we will talk about what happens when something goes wrong while you work with the API.

Databases Just as providers can be easily exchanged between adapters, we can do the same with the database. Now the important thing to understand is how it works. The main purpose of the database inside the bot is to provide the bot with a record of the different events that have occurred between different conversations. Many people use it as a chat history (in fact, it can also be used for that purpose), but you may find strange data in your logs because it stores not only messages, but also events. Connectors: MemoryDB, Json, Mongo, MySQL, Postgres, Custom Database Each database may need to adjust the access keys, configuration, among other properties that will be implemented as configuration of the implemented class. memory-database.tsjson-database.tsmongo-database.tsmysql-database.tspostgres-database.tsimport { MemoryDB } from "@builderbot/bot"; export type IDatabase = typeof MemoryDB export const adapterDB = new MemoryDB(); CopyCopied! Below you will find more information about each of these databases. Memory The Memory database, often called a Mock database, operates without storing bot-generated responses and needs no configuration. Primarily used for testing and development, it offers a lightweight and convenient solution. This database type is ideal for scenarios where data persistence isn't necessary, facilitating quick prototyping and efficient debugging without managing persistent data storage overhead. memory-database.tsapp.tsimport { MemoryDB } from "@builderbot/bot"; export type IDatabase = typeof MemoryDB export const adapterDB = new MemoryDB(); CopyCopied! Json JSON database provides the benefit of securely storing bot-generated responses in a local file, ensuring durability across sessions. Utilizing this database type requires specifying a file path (filename) where the JSON data will be stored. It proves particularly valuable when preserving conversation history or user interactions is imperative. By enabling structured data storage, it simplifies data retrieval and analysis, rendering it appropriate for applications where data persistence and retrieval play a critical role. json-database.tsapp.tsimport { JsonFileDB } from '@builderbot/database-json'; export type IDatabase = typeof JsonFileDB export const adapterDB = new JsonFileDB({ filename: 'db.json' }); CopyCopied! Mongo MongoDB strength lies in its flexible document-oriented structure, which requires configuration parameters like the database URI and name (dbUri, dbName). Its scalable architecture provides robust storage capabilities, ideal for handling large data volumes. By embracing a NoSQL approach, MongoDB offers flexibility in schema design, effortlessly accommodating evolving application needs. It proves particularly suitable for environments requiring high-performance data storage and retrieval, thanks to its efficient indexing and querying functionalities. mongo-database.tsapp.tsimport { MongoDB } from '@builderbot/database-mongo' export type IDatabase = typeof MongoDB export const adapterDB = new MongoDB({ dbUri: MONGO_DB_URI, dbName: MONGO_DB_NAME, }) CopyCopied! MySQL MySQL database, a widely embraced relational database management system, provides strong data storage capabilities for storing bot-generated responses. When integrating with MySQL, essential parameters such as host, user, password, and the database name must be specified. This database variant assures data durability and scalability, rendering it well-suited for applications demanding high-performance data storage and retrieval. With MySQL, developers can harness advanced querying features and transaction support, facilitating efficient management of bot-generated data within a structured and secure framework. mysql-database.tsapp.tsimport { MysqlDB } from '@builderbot/database-mysql' export type IDatabase = typeof MysqlDB export const adapterDB = new MysqlDB({ host: MYSQL_DB_HOST, user: MYSQL_DB_USER, database: MYSQL_DB_NAME, password: MYSQL_DB_PASSWORD, }) CopyCopied! Postgres PostgreSQL database, celebrated for its reliability and cutting-edge features, presents formidable data storage solutions for bot-generated responses. Seamless integration with PostgreSQL entails specifying vital parameters such as host, user, password, database name, and port. This database variant guarantees data integrity and scalability, rendering it optimal for applications requiring top-tier data storage and retrieval performance. Uses Cases If you want connect your bot to cloud database like Supabase or any CloudProvider you can use it. More info about Postgres connection uses cases PostgreSQL's flexible architecture and endorsement of advanced data types empower developers to craft sophisticated bots endowed with extensive functionality. Leveraging PostgreSQL equips developers with potent querying capabilities, transactional support, and comprehensive data management features, fostering the creation of resilient and efficient bot systems. postgres-database.tsapp.tsimport { PostgreSQLDB } from '@builderbot/database-postgres' export type IDatabase = typeof PostgreSQLDB export const adapterDB = new PostgreSQLDB({ host: POSTGRES_DB_HOST, user: POSTGRES_DB_USER, database: POSTGRES_DB_NAME, password: POSTGRES_DB_PASSWORD, port: +POSTGRES_DB_PORT, }) CopyCopied! Firebase Database AdapterCustom Database Custom database connector there is the possibility to build your own customized adapter, we know that there are many more database providers that can be very useful, an example can be Firebase Console which apart from giving us the possibility to interact via API Rest also offers a Dashboard to visualize your data. app.tsdatabase/firebase.tsdatabase/types.tsimport { createBot, createProvider, createFlow, addKeyword } from '@builderbot/bot' import { BaileysProvider as Provider } from '@builderbot/provider-baileys' import { FirebaseAdapter } from './database/firebase' const PORT = process.env.PORT ?? 3008 const welcomeFlow = addKeyword<Provider, FirebaseAdapter>(['hi']) .addAnswer('Ey! welcome') const main = async () => { const adapterFlow = createFlow([welcomeFlow]) const adapterProvider = createProvider(Provider) const adapterDB = new FirebaseAdapter({ databaseURL: 'YOUR URL FIREBASE REALTIME DATABASE', pathPrivateKeyJson: "YOUR PATH CREDENTIALS JSON FIREBASE" })() const { httpServer } = await createBot({ flow: adapterFlow, provider: adapterProvider, database: adapterDB, }) httpServer(+PORT) } main() CopyCopied!

================================================================================

## CONTRIBUTING - BuilderBot.app Chatbot for Whatsapp, Telegram and more
URL: https://builderbot.vercel.app/en/plugins#welcome
Section: General
Importance: 0.50
Description: Contributing with us, join and coding side to side a great community

CONTRIBUTING Welcome We're glad that you're interested in contributing to our project! Here you will find all the necessary information to start collaborating. You can contribute in various ways, whether it's updating the documentation, improving the code, reviewing pending issues in the issues, or even making financial contributions, which will be used for various purposes related to the development and maintenance of the project. You can see more details on how to make financial contributions here. The main language we use in this project is TypeScript, which allows us to maintain readable and scalable code. Frequent Questions Here are some answers to frequently asked questions that may arise when contributing to the project: What is Lerna? You can find an explanation in this video. How do I make commits effectively? Here's a video that shows you how to do it. What are our communication channels? You can join our community on Discord. Requirements: Before starting to contribute to the project, make sure you have the following tools installed: Node.js: Version 18 or higher. You can download Node from here. pnpm: Package manager. You can install it by following the instructions here. VSCode: Code editor that we recommend, as it has useful plugins. Conventional Commits: VSCode plugin that helps you create semantic commits, following best practices. You can install it from here. Get Starter Make a fork Before starting work on the project, fork it to your own GitHub account. This will allow you to work on your own copy of the repository. Click on the following link to fork: here. Clone the Repository (from your fork) Once you have forked the project, clone your own copy of the repository using the following command in your terminal: git clone https://github.com/TU_USERNAME/bot-plugins CopyCopied! Dependencies install Go to the project folder and run the following commands to install the necessary dependencies: cd bot-plugins pnpm install pnpm run build CopyCopied! Create a new integration To create a new integration, run the following command in your terminal: pnpm run create.package <package_name> CopyCopied! compile (build) To compile the application, run the following command in your terminal. This will generate a dist directory within the monorepo packages. npx lerna run build --scope=<package_name> CopyCopied! tests environments Once you have run the build and everything is correct, run the following command in your terminal: pnpm run copy.lib CopyCopied! This command will copy the necessary files into the base_app folder. Make sure you have previously run npm install within the base_app folder. Then, from the root of your directory, run: pnpm run copy.lib CopyCopied! To start the assistant, run: npm run dev CopyCopied! It should work smoothly. Test End-to-End (E2E) All changes made must pass the end-to-end tests. These tests are run with the following command: pnpm run test CopyCopied! Make sure you have a test folder and files with the .test.ts extension for your tests.

================================================================================

## Meta Provider - BuilderBot.app Chatbot for Whatsapp, Telegram and more
URL: https://builderbot.vercel.app/providers/meta
Section: General
Importance: 0.50
Description: In this guide, we will discuss what to do when something goes wrong while working with the API.

Meta Provider The WhatsApp Business Platform allows medium and large businesses to communicate with their customers on a large scale. You can start conversations with customers in just a few minutes, send them customer service notifications or purchase updates, offer them a personalized level of service, and provide support through their preferred channel. Requirements Register a Facebook Developers account. You will need to verify your business and your application with official documents, the type of which may vary depending on your country. You will need to associate an official phone number of your business with your account that is not linked to any other WhatsApp account, either regular or Business. For testing purposes, Meta provides a free phone number. Meta offers 1000 free customer-initiated conversations to the bot, and 250 free bot-initiated conversations to the customer. Once this limit is reached, each additional conversation will have a cost that may vary depending on your country or region. More info about Meta Deploy Uses Cases If you want to give a quick overview of all the options that this provider allows you to implement in conjunction with builderbot you can go through the use cases, where in code we show some of the most important features of this provider. Cases such as sending buttons, lists, or native methods directly with Meta More info about Meta uses cases Meta tutorial video If you are one of those people who prefer to watch videos, here is a short tutorial on how to implement the Meta base. Video Meta Provider You must create a new application. To do this, click on the Create application button. On this screen, you must select Company or Business. In the next step, you must enter a name for your application, also enter a contact email address and select the Test Business application. Now, go to the WhatsApp Settings section. This is the part where you will find the access token and you can also see the number from where WhatsApp messages are sent and to where they will be sent. As you are in the trial version, you must register the numbers to which you want to send. On this same page, you can find the Webhook section that we will soon need to use. In the main file of the bot where you are implementing the meta adapter function, you are going to place the following data: numberId: You can find it on the previous page. jwtToken: You can find it on the previous page. VerifyToken: You can write whatever you want, it's like a keyword. In the example below, you can see a suggestion of how this can be done by using environment variables const main = async () => { const adapterDB = new MockAdapter() const adapterFlow = createFlow([flowPrincipal]) const adapterProvider = createProvider(MetaProvider, { jwtToken: process.env.JWTOKEN, //EAARBW3ZBGU0UBAACDjtQIzI8JuEa............. numberId: process.env.NUMBER_ID, //103975305758520 verifyToken: process.env.VERIFY_TOKEN, //LO_QUE_SEA, version:'v16.0' }) createBot({ flow: adapterFlow, provider: adapterProvider, database: adapterDB, }) } main() CopyCopied! After executing the bot, you will find a message in the console similar to the following. Where you can find the URL for your webhook. $ npm start > node app.js [meta]: Add this url "WHEN A MESSAGE COMES IN" [meta]: POST http://localhost:3000/webhook [meta]: More information in the documentation CopyCopied! What do I do now? You will notice that the bot starts an HTTP service (endpoint) that must be online on a server so that you can connect it with Meta. Option 1: You can test locally through a proxy tunnel server. Download ngork, a free tool that will help with this. This generates an online URL that we can use in the WebHook section of Meta Option 2: If you have already deployed your bot on a server, you need to obtain the public IP or subdomain provided to you. Example if you are using Railway, you can go to the settings section and generate a subdomain. We would then have the WebHook https://base-twilio-memory-production.up.railway.app/twilio-hook GuidesMy first chatbotLearn how build your first chatbot in few minutesRead moreConceptsUnderstand the essential concepts for building botsRead moreAdd FunctionsThe key to learning how to write flows is add-functions.Read morePluginsUnlimitate and start implementing the community plugins.Read more ResourcesModularizeLearn how to modularise flows so that you can have a more maintainable bot.Send MessageHow to send a message via HTTP to start conversations, you can send multimedia as well.DockerizerA good practice is to dockerise your bots to make them more maintainable and effective.EventsLearning about events will make us more fluent when creating chatbots.

================================================================================

## Twilio Provider - BuilderBot.app Chatbot for Whatsapp, Telegram and more
URL: https://builderbot.vercel.app/providers/twilio
Section: General
Importance: 0.50
Description: In this guide, we will discuss what to do when something goes wrong while working with the API.

Twilio Provider Twilio is a development platform that enables developers to build cloud communication applications and web systems. Twilio's communication APIs empower businesses to provide the appropriate communication experience for their customers within web and mobile applications. By leveraging Twilio's APIs, developers can swiftly integrate functionalities such as voice messages, video calls, text messages, and more into an application. Twilio provides you with a Sandbox account so you can try the service for free. Register a Twilio account. If you want to take a closer look at the process of setting up your Twilio environment to start creating your chatbot, click here. More info about Twilio Deploy Uses Cases If you want to give a quick overview of all the options that this provider allows you to implement in conjunction with builderbot you can go through the use cases, where in code we show some of the most important features of this provider. Cases such as sending buttons, lists, or native methods directly with Meta More info about Twilio uses cases Send Buttons One of the most requested functions by users is the fact of sending buttons to generate more interactivity and more dynamic chatbots. app.tsconst welcomeFlow = addKeyword<Provider, Database>(['template','plantilla']) .addAction(async (ctx) => { await provider.send(ctx.from, 'Agregar dos botones que permiten al cliente dar una respuesta mas rapida', { contentSid: 'HXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX' } ) }) CopyCopied! Remember that the use of buttons, lists and other featured Whatsapp functionality needs to be a template authorized by the provider. contentSid is the id of the approved template you can use. Content Quick Remember for correct functionality you must have the message comply with the message template constructed. Buttons Examples Content Template Builder The Content Template Builder is a Twilio product designed to create template messages and content-rich messages. It has an easy-to-use graphical interface built on a publicly accessible API. With the Content Template Builder, both engineers and non-technical users can create, approve and manage templates from the Twilio Console. With this system, it is possible to create templates faster, with fewer errors, while empowering the entire team to contribute. Both developers and non-technical users can build and submit templates for approval from the Twilio Console without writing a single line of code. Content Templates GuidesMy first chatbotLearn how build your first chatbot in few minutesRead moreConceptsUnderstand the essential concepts for building botsRead moreAdd FunctionsThe key to learning how to write flows is add-functions.Read morePluginsUnlimitate and start implementing the community plugins.Read more ResourcesModularizeLearn how to modularise flows so that you can have a more maintainable bot.Send MessageHow to send a message via HTTP to start conversations, you can send multimedia as well.DockerizerA good practice is to dockerise your bots to make them more maintainable and effective.EventsLearning about events will make us more fluent when creating chatbots.

================================================================================

## Modularize Flows - BuilderBot.app Chatbot for Whatsapp, Telegram and more
URL: https://builderbot.vercel.app/en/showcases/modularize#issue
Section: General
Importance: 0.40
Description: Implement message queues for better resource management

Modularize Flows Issue My application grew so large that I was having trouble maintaining it and the code was becoming spaghetti code. Possible Solution As our projects grow we will need to implement a better way to maintain the project, in this case it is highly recommended to implement a module view. In the following example we will show how we have migrated the modules to a directory, as well as the provider and the database. app.tsprovider/index.tsdatabase/index.tsflow/index.tsflow/welcome.flow.tsservices/ai.ts import { createBot } from '@builderbot/bot'; import { flow } from "./flow"; import { database } from "./database"; import { provider } from "./provider"; import { ai } from "./services/ai"; const main = async () => { await createBot({ flow, provider, database, }, extensions: { ai // Dependency AI }) provider.initHttpServer(3000) } main() CopyCopied! An example of the scaffolding you can use in your project. Or a more user friendly folder structure. structuresrc ├── app.ts ├── database │ └── index.ts ├── flow │ ├── index.ts │ └── welcome.flow.ts │ └── bye.flow.ts │ └── media.flow.ts ├── provider │ └── index.ts └── services └── ai.ts CopyCopied! GuidesMy first chatbotLearn how build your first chatbot in few minutesRead moreConceptsUnderstand the essential concepts for building botsRead moreAdd FunctionsThe key to learning how to write flows is add-functions.Read morePluginsUnlimitate and start implementing the community plugins.Read more ResourcesModularizeLearn how to modularise flows so that you can have a more maintainable bot.Send MessageHow to send a message via HTTP to start conversations, you can send multimedia as well.DockerizerA good practice is to dockerise your bots to make them more maintainable and effective.EventsLearning about events will make us more fluent when creating chatbots.

================================================================================

## Deploy - BuilderBot.app Chatbot for Whatsapp, Telegram and more
URL: https://builderbot.vercel.app/en/deploy/docker#portainer
Section: General
Importance: 0.40
Description: In this guide, we will discuss how to create a Dockerfile and how to deploy your bot.

Deploy Previously, you need to have Docker installed on your server depending on the operating system, the processes change, you can find all the official information about docker at this link. Depending on the provider you have chosen, you will need a specific Docker implementation, but don't worry, as it comes automatically implemented in a file called Dockerfile, you can also view the other Dockerfiles in the templates section. Dockerfile, Build Image, Run Container, Portainer Dockerfile# THIS IS THE BASE IMAGE FOR THE BOT FROM node:21-alpine3.18 as builder # Enable Corepack and prepare for PNPM installation to increase performance RUN corepack enable && corepack prepare pnpm@latest --activate ENV PNPM_HOME=/usr/local/bin # Set the working directory WORKDIR /app # Copy package.json and pnpm-lock.yaml files to the working directory COPY package*.json pnpm-lock.yaml ./ # Install dependencies using PNPM COPY . . RUN pnpm i # Create a new stage for deployment FROM builder as deploy # Copy only necessary files and directories for deployment COPY --from=builder /app/src ./src COPY --from=builder /app/package.json /app/pnpm-lock.yaml ./ RUN pnpm install CMD ["pnpm", "start"] CopyCopied! Build Image In this step, we are going to build the Docker image with all the settings of your project, remember that depending on the libraries you are using, you may need to modify the Dockerfile for it to function correctly. Build Imagedocker build . -t builderbot:latest CopyCopied! You can see in your console that the image starts to build and the process logs are coming out, you must ensure that it ends with naming to docker.io/library/builderbot:latest => [internal] load build definition from Dockerfile 0.4s => [internal] load metadata for docker.io/library/node:21-alpine3.18 3.6s => .................... => => naming to docker.io/library/builderbot:latest CopyCopied! Run Container To run your containerized image by passing different environment variables depending on the configuration needed, you can do it in the following way. Remember to release the corresponding ports in your server's firewall. Example 3008 Run Container FullRun Container Quickdocker rm -f bot 2>/dev/null docker run \ --name "bot" \ --env OPENAI_API_KEY="your_api_key_value" \ --env PORT=3008 \ -p 3008:3008/tcp \ -v "$(pwd)/bot_sessions:/app/bot_sessions:rw" \ --cap-add SYS_ADMIN \ --restart always \ builderbot:latest CopyCopied! CommandExplanationdocker rm -f bot 2>/dev/nullDeletes any running container named "bot", if it exists. The 2>/dev/null redirects any error message to nothing, meaning if the container doesn't exist, no error message will be displayed.docker run -dStarts a new Docker container in detached mode (in the background).--name "bot"Assigns the name "amazing-bot" to the container.--env OPENAI_API_KEY="API"Sets the environment variable OPENAI_API_KEY inside the container to the provided value, which should be a valid API key to access OpenAI.--user $(id -u):$(id -g)Specifies the user and group under which the process will run inside the container. $(id -u) gets the current user ID of the system and $(id -g) gets the current group ID.-p 3008:3008/tcpPublishes port 3008 of the container to port 3008 of the host, allowing traffic to be directed to the container's port.-v $(pwd)/bot_sessions:/app/bot_sessions:rwMounts the host directory /root/sessions/bot_sessions to the container directory /app/bot_sessions with read-write permissions (rw).--cap-add SYS_ADMINGrants the container the SYS_ADMIN capability, providing a broad set of system administration capabilities.--restart alwaysConfigures the container to restart automatically if it stops or encounters an error.builderbot:latestSpecifies the Docker image to be used for creating and running the container. In this case, builderbot:latest is the image tag. Portainer If you are already familiar with docker and want to manage different bots mounted in containers a good OpenSource option is portainer. Portainer Community Edition is a user-friendly platform tailored for managing containerized applications across various environments like Docker, Swarm, Kubernetes, and ACI. With its straightforward deployment and intuitive interface, it simplifies the management of container resources such as images, volumes, and networks through a graphical interface or an API. Portainer operates within a single container, adaptable to both Linux and Windows environments. List of bots

================================================================================

## Providers - BuilderBot.app Chatbot for Whatsapp, Telegram and more
URL: https://builderbot.vercel.app/en/providers#meta
Section: General
Importance: 0.40
Description: In this guide, we will talk about what happens when something goes wrong while you work with the API.

Providers Providers are in charge of providing the communication bridge between your bot and whatsapp, telegram or custom provider. You can change your provider very easily without affecting the logic of your bot. It is as simple as implementing the connector of the provider of your choice. At the moment we have integrations with more than four suppliers. Whatsapp: Meta, Twilio, Baileys, WPPConnect, Venom, Telegram, Custom Provider Each provider may need to adjust access keys, settings, among other properties that are usually passed as an object in the createProvider function. meta-provider.tstwilio-provider.tsbaileys-provider.tsvenom-provider.tswppconnect-provider.tsimport { createProvider } from "@builderbot/bot"; import { MetaProvider } from '@builderbot/provider-meta'; export type IProvider = typeof MetaProvider export const adapterProvider = createProvider(MetaProvider, { jwtToken: 'jwtToken', numberId: 'numberId', verifyToken: 'verifyToken', version: 'v16.0', }) CopyCopied! Below you will find more information about each of these providers. Meta The WhatsApp Business Platform enables medium and large businesses to communicate with their customers on a large scale. You can initiate conversations with customers in just minutes, send them customer service notifications or purchase updates, offer them a personalized level of service, and provide support through the channel of their choice. meta-provider.tsapp.tsimport { createProvider } from "@builderbot/bot"; import { MetaProvider } from '@builderbot/provider-meta'; export type IProvider = typeof MetaProvider export const adapterProvider = createProvider(MetaProvider, { jwtToken: 'jwtToken', numberId: 'numberId', verifyToken: 'verifyToken', version: 'v16.0', }) CopyCopied! More info about Meta provider Twilio Twilio is a development platform that enables developers to build cloud communication applications and web systems. Twilio's communications APIs enable businesses to provide the right communication experience for their customers within web and mobile applications. By using Twilio APIs, developers can quickly add this functionality to an application, such as voice messaging, video calls, text messaging and more. twilio-provider.tsapp.tsimport { createProvider } from "@builderbot/bot"; import { TwilioProvider } from '@builderbot/provider-twilio'; export type IProvider = typeof TwilioProvider export const adapterProvider = createProvider(TwilioProvider, { accountSid: 'YOUR_ACCOUNT_SID', authToken: 'YOUR_ACCOUNT_TOKEN', vendorNumber: '+14155238886', publicUrl: "public_url", //optional }); CopyCopied! More info about Twilio provider Baileys Baileys is an open source project which allows sending messages, receiving messages and dozens of other features by implementing WebSocket in a version of whatsapp. It is a project with great trajectory driven by people with great knowledge of the subject, you can deepen in this library directly in its documentation or repository. Because this is a free provider that emulates the whatsapp web interface, you must scan the QR to log in. If you want to see more examples taking full advantage of this provider in conjunction with the builderbot library you can check this @jorgechavarriaga repository baileys-provider.tsbaileys-provider-extend.tsapp.tsimport { createProvider } from "@builderbot/bot"; import { BaileysProvider } from '@builderbot/provider-baileys'; export type IProvider = typeof BaileysProvider export const adapterProvider = createProvider(BaileysProvider) CopyCopied! Venom Venom is an open-source project that utilizes JavaScript to create high-performance bots for WhatsApp. It supports a wide range of interactions including customer care, media sending, AI-based phrase recognition, and various architectural designs tailored for WhatsApp. You can visit their official website as the repository to understand other features you can use. Because this is a free provider that emulates the whatsapp web interface, you must scan the QR to log in. venom-provider.tsvenom-provider-extend.tsapp.tsimport { createProvider } from "@builderbot/bot"; import { VenomProvider } from '@builderbot/provider-venom'; export type IProvider = typeof VenomProvider export const adapterProvider = createProvider(VenomProvider) CopyCopied! WPPConnect WPPConnect is an open source project developed by the JavaScript community with the aim of exporting functions from WhatsApp Web to the node, which can be used to support the creation of any interaction, such as customer service, media sending, intelligence recognition based on phrases artificial and many other things, use your imagination You can visit their official website as the repository to understand other features you can use. Because this is a free provider that emulates the whatsapp web interface, you must scan the QR to log in. wppconnect-provider.tswppconnect-provider-extend.tsapp.tsimport { createProvider } from "@builderbot/bot"; import { WPPConnectProvider } from '@builderbot/provider-wppconnect'; export type IProvider = typeof WPPConnectProvider export const adapterProvider = createProvider(WPPConnectProvider) CopyCopied! Wali.chat ProviderCustom Provider Custom provider there is the possibility to build your own customized adapter, we know that there are many more providers that can be very useful, an example can be Wali.chat which apart from giving us the possibility to interact via API Rest also offers a Dashboard to visualize and share data with your agents. app.tsprovider/wali.tsprovider/wali.events.tsimport { createBot, createProvider, createFlow, addKeyword, utils } from '@builderbot/bot' import { MemoryDB as Database } from '@builderbot/bot' import { WaliProvider as Provider } from './provider/wali' const PORT = process.env.PORT ?? 3008 const fullSamplesFlow = addKeyword<Provider, Database>(['samples', utils.setEvent('SAMPLES')]) .addAnswer(`💪 I'll send you a lot files...`) .addAnswer(`Send video from URL`, { media: 'https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExYTJ0ZGdjd2syeXAwMjQ4aWdkcW04OWlqcXI3Ynh1ODkwZ25zZWZ1dCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/LCohAb657pSdHv0Q5h/giphy.mp4' } ) .addAnswer(`Send audio from URL`, { media: 'https://cdn.freesound.org/previews/728/728142_11861866-lq.mp3' } ) .addAnswer(`Send file from URL`, { media: 'https://www.w3.org/WAI/ER/tests/xhtml/testfiles/resources/pdf/dummy.pdf' } ) const main = async () => { const adapterFlow = createFlow([fullSamplesFlow]) const adapterProvider = createProvider(Provider, { token: process.env.TOKEN, deviceId: process.env.DEVICE_ID }) const adapterDB = new Database() const { httpServer } = await createBot({ flow: adapterFlow, provider: adapterProvider, database: adapterDB, }) httpServer(+PORT) } main() CopyCopied!

================================================================================

## Databases - BuilderBot.app Chatbot for Whatsapp, Telegram and more
URL: https://builderbot.vercel.app/en/databases#json
Section: General
Importance: 0.40
Description: In this guide, we will talk about what happens when something goes wrong while you work with the API.

Databases Just as providers can be easily exchanged between adapters, we can do the same with the database. Now the important thing to understand is how it works. The main purpose of the database inside the bot is to provide the bot with a record of the different events that have occurred between different conversations. Many people use it as a chat history (in fact, it can also be used for that purpose), but you may find strange data in your logs because it stores not only messages, but also events. Connectors: MemoryDB, Json, Mongo, MySQL, Postgres, Custom Database Each database may need to adjust the access keys, configuration, among other properties that will be implemented as configuration of the implemented class. memory-database.tsjson-database.tsmongo-database.tsmysql-database.tspostgres-database.tsimport { MemoryDB } from "@builderbot/bot"; export type IDatabase = typeof MemoryDB export const adapterDB = new MemoryDB(); CopyCopied! Below you will find more information about each of these databases. Memory The Memory database, often called a Mock database, operates without storing bot-generated responses and needs no configuration. Primarily used for testing and development, it offers a lightweight and convenient solution. This database type is ideal for scenarios where data persistence isn't necessary, facilitating quick prototyping and efficient debugging without managing persistent data storage overhead. memory-database.tsapp.tsimport { MemoryDB } from "@builderbot/bot"; export type IDatabase = typeof MemoryDB export const adapterDB = new MemoryDB(); CopyCopied! Json JSON database provides the benefit of securely storing bot-generated responses in a local file, ensuring durability across sessions. Utilizing this database type requires specifying a file path (filename) where the JSON data will be stored. It proves particularly valuable when preserving conversation history or user interactions is imperative. By enabling structured data storage, it simplifies data retrieval and analysis, rendering it appropriate for applications where data persistence and retrieval play a critical role. json-database.tsapp.tsimport { JsonFileDB } from '@builderbot/database-json'; export type IDatabase = typeof JsonFileDB export const adapterDB = new JsonFileDB({ filename: 'db.json' }); CopyCopied! Mongo MongoDB strength lies in its flexible document-oriented structure, which requires configuration parameters like the database URI and name (dbUri, dbName). Its scalable architecture provides robust storage capabilities, ideal for handling large data volumes. By embracing a NoSQL approach, MongoDB offers flexibility in schema design, effortlessly accommodating evolving application needs. It proves particularly suitable for environments requiring high-performance data storage and retrieval, thanks to its efficient indexing and querying functionalities. mongo-database.tsapp.tsimport { MongoDB } from '@builderbot/database-mongo' export type IDatabase = typeof MongoDB export const adapterDB = new MongoDB({ dbUri: MONGO_DB_URI, dbName: MONGO_DB_NAME, }) CopyCopied! MySQL MySQL database, a widely embraced relational database management system, provides strong data storage capabilities for storing bot-generated responses. When integrating with MySQL, essential parameters such as host, user, password, and the database name must be specified. This database variant assures data durability and scalability, rendering it well-suited for applications demanding high-performance data storage and retrieval. With MySQL, developers can harness advanced querying features and transaction support, facilitating efficient management of bot-generated data within a structured and secure framework. mysql-database.tsapp.tsimport { MysqlDB } from '@builderbot/database-mysql' export type IDatabase = typeof MysqlDB export const adapterDB = new MysqlDB({ host: MYSQL_DB_HOST, user: MYSQL_DB_USER, database: MYSQL_DB_NAME, password: MYSQL_DB_PASSWORD, }) CopyCopied! Postgres PostgreSQL database, celebrated for its reliability and cutting-edge features, presents formidable data storage solutions for bot-generated responses. Seamless integration with PostgreSQL entails specifying vital parameters such as host, user, password, database name, and port. This database variant guarantees data integrity and scalability, rendering it optimal for applications requiring top-tier data storage and retrieval performance. Uses Cases If you want connect your bot to cloud database like Supabase or any CloudProvider you can use it. More info about Postgres connection uses cases PostgreSQL's flexible architecture and endorsement of advanced data types empower developers to craft sophisticated bots endowed with extensive functionality. Leveraging PostgreSQL equips developers with potent querying capabilities, transactional support, and comprehensive data management features, fostering the creation of resilient and efficient bot systems. postgres-database.tsapp.tsimport { PostgreSQLDB } from '@builderbot/database-postgres' export type IDatabase = typeof PostgreSQLDB export const adapterDB = new PostgreSQLDB({ host: POSTGRES_DB_HOST, user: POSTGRES_DB_USER, database: POSTGRES_DB_NAME, password: POSTGRES_DB_PASSWORD, port: +POSTGRES_DB_PORT, }) CopyCopied! Firebase Database AdapterCustom Database Custom database connector there is the possibility to build your own customized adapter, we know that there are many more database providers that can be very useful, an example can be Firebase Console which apart from giving us the possibility to interact via API Rest also offers a Dashboard to visualize your data. app.tsdatabase/firebase.tsdatabase/types.tsimport { createBot, createProvider, createFlow, addKeyword } from '@builderbot/bot' import { BaileysProvider as Provider } from '@builderbot/provider-baileys' import { FirebaseAdapter } from './database/firebase' const PORT = process.env.PORT ?? 3008 const welcomeFlow = addKeyword<Provider, FirebaseAdapter>(['hi']) .addAnswer('Ey! welcome') const main = async () => { const adapterFlow = createFlow([welcomeFlow]) const adapterProvider = createProvider(Provider) const adapterDB = new FirebaseAdapter({ databaseURL: 'YOUR URL FIREBASE REALTIME DATABASE', pathPrivateKeyJson: "YOUR PATH CREDENTIALS JSON FIREBASE" })() const { httpServer } = await createBot({ flow: adapterFlow, provider: adapterProvider, database: adapterDB, }) httpServer(+PORT) } main() CopyCopied!

================================================================================

